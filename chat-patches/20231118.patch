diff --git a/src/vs/workbench/contrib/csChat/browser/actions/csChatActions.ts b/src/vs/workbench/contrib/csChat/browser/actions/csChatActions.ts
index 8d70003a263..0ae0c38150c 100644
--- a/src/vs/workbench/contrib/csChat/browser/actions/csChatActions.ts
+++ b/src/vs/workbench/contrib/csChat/browser/actions/csChatActions.ts
@@ -32,6 +32,8 @@ import { LifecyclePhase } from 'vs/workbench/services/lifecycle/common/lifecycle
 import { AccessibilityHelpAction } from 'vs/workbench/contrib/accessibility/browser/accessibleViewActions';
 import { IChatAgentService } from 'vs/workbench/contrib/chat/common/chatAgents';
 import { chatAgentLeader } from 'vs/workbench/contrib/chat/common/chatParserTypes';
+import { IChatContributionService } from 'vs/workbench/contrib/chat/common/chatContributionService';
+import { IViewsService } from 'vs/workbench/common/views';
 
 export const CHAT_CATEGORY = { value: localize('chat.category', "Chat"), original: 'Chat' };
 export const CHAT_OPEN_ACTION_ID = 'workbench.action.chat.open';
@@ -239,7 +241,7 @@ const getHistoryChatActionDescriptorForViewTitle = (viewId: string, providerId:
 		id: MenuId.ViewTitle,
 		when: ContextKeyExpr.equals('view', viewId),
 		group: 'navigation',
-		order: 0
+		order: -1
 	},
 	category: CHAT_CATEGORY,
 	icon: Codicon.history,
@@ -256,7 +258,8 @@ export function getHistoryAction(viewId: string, providerId: string) {
 		async runInView(accessor: ServicesAccessor, view: ChatViewPane) {
 			const chatService = accessor.get(IChatService);
 			const quickInputService = accessor.get(IQuickInputService);
-			const editorService = accessor.get(IEditorService);
+			const chatContribService = accessor.get(IChatContributionService);
+			const viewsService = accessor.get(IViewsService);
 			const items = chatService.getHistory();
 			const picks = items.map(i => (<IQuickPickItem & { chat: IChatDetail }>{
 				label: i.title,
@@ -268,7 +271,7 @@ export function getHistoryAction(viewId: string, providerId: string) {
 			}));
 			const selection = await quickInputService.pick(picks,
 				{
-					placeHolder: localize('interactiveSession.history.pick', "Select a chat session to restore"),
+					placeHolder: localize('interactiveSession.history.pick', "Switch to chat session"),
 					onDidTriggerItemButton: context => {
 						chatService.removeHistoryEntry(context.item.chat.sessionId);
 						context.removeItem();
@@ -276,9 +279,12 @@ export function getHistoryAction(viewId: string, providerId: string) {
 				});
 			if (selection) {
 				const sessionId = selection.chat.sessionId;
-				await editorService.openEditor({
-					resource: ChatEditorInput.getNewEditorUri(), options: <IChatEditorOptions>{ target: { sessionId }, pinned: true }
-				});
+				const provider = chatContribService.registeredProviders[0]?.id;
+				if (provider) {
+					const viewId = chatContribService.getViewIdForProvider(provider);
+					const view = await viewsService.openView(viewId) as ChatViewPane;
+					view.loadSession(sessionId);
+				}
 			}
 		}
 	};
diff --git a/src/vs/workbench/contrib/csChat/browser/actions/csChatClearActions.ts b/src/vs/workbench/contrib/csChat/browser/actions/csChatClearActions.ts
index c7650d78ca8..d45fad58121 100644
--- a/src/vs/workbench/contrib/csChat/browser/actions/csChatClearActions.ts
+++ b/src/vs/workbench/contrib/csChat/browser/actions/csChatClearActions.ts
@@ -6,7 +6,7 @@
 import { Codicon } from 'vs/base/common/codicons';
 import { KeyCode, KeyMod } from 'vs/base/common/keyCodes';
 import { ServicesAccessor } from 'vs/editor/browser/editorExtensions';
-import { localize } from 'vs/nls';
+import { localize2 } from 'vs/nls';
 import { AccessibleNotificationEvent, IAccessibleNotificationService } from 'vs/platform/accessibility/common/accessibility';
 import { Action2, IAction2Options, MenuId, registerAction2 } from 'vs/platform/actions/common/actions';
 import { ContextKeyExpr } from 'vs/platform/contextkey/common/contextkey';
@@ -28,11 +28,8 @@ export function registerClearActions() {
 		constructor() {
 			super({
 				id: 'workbench.action.chatEditor.clear',
-				title: {
-					value: localize('interactiveSession.clear.label', "Clear"),
-					original: 'Clear'
-				},
-				icon: Codicon.clearAll,
+				title: localize2('chat.newSession.label', "New Session"),
+				icon: Codicon.plus,
 				f1: false,
 				precondition: CONTEXT_PROVIDER_EXISTS,
 				menu: [{
@@ -54,10 +51,7 @@ export function registerClearActions() {
 		constructor() {
 			super({
 				id: ACTION_ID_CLEAR_CHAT,
-				title: {
-					value: localize('interactiveSession.clear.label', "Clear"),
-					original: 'Clear'
-				},
+				title: localize2('chat.newSession.label', "New Session"),
 				category: CHAT_CATEGORY,
 				icon: Codicon.clearAll,
 				precondition: CONTEXT_PROVIDER_EXISTS,
@@ -69,12 +63,15 @@ export function registerClearActions() {
 						primary: KeyMod.WinCtrl | KeyCode.KeyL
 					},
 					when: CONTEXT_IN_CHAT_SESSION
+				},
+				menu: {
+					id: MenuId.ChatContext,
+					group: 'z_clear'
 				}
 			});
 		}
 
 		run(accessor: ServicesAccessor, ...args: any[]) {
-			announceChatCleared(accessor);
 			const widgetService = accessor.get(IChatWidgetService);
 
 			const widget = widgetService.lastFocusedWidget;
@@ -82,6 +79,7 @@ export function registerClearActions() {
 				return;
 			}
 
+			announceChatCleared(accessor);
 			widget.clear();
 		}
 	});
@@ -90,19 +88,16 @@ export function registerClearActions() {
 const getClearChatActionDescriptorForViewTitle = (viewId: string, providerId: string): Readonly<IAction2Options> & { viewId: string } => ({
 	viewId,
 	id: `workbench.action.chat.${providerId}.clear`,
-	title: {
-		value: localize('interactiveSession.clear.label', "Clear"),
-		original: 'Clear'
-	},
+	title: localize2('chat.newSession.label', "New Session"),
 	menu: {
 		id: MenuId.ViewTitle,
 		when: ContextKeyExpr.equals('view', viewId),
 		group: 'navigation',
-		order: 0
+		order: -1
 	},
 	precondition: CONTEXT_PROVIDER_EXISTS,
 	category: CHAT_CATEGORY,
-	icon: Codicon.clearAll,
+	icon: Codicon.plus,
 	f1: false
 });
 
diff --git a/src/vs/workbench/contrib/csChat/browser/actions/csChatCodeblockActions.ts b/src/vs/workbench/contrib/csChat/browser/actions/csChatCodeblockActions.ts
index 4a5e08e11f5..d0713c603ce 100644
--- a/src/vs/workbench/contrib/csChat/browser/actions/csChatCodeblockActions.ts
+++ b/src/vs/workbench/contrib/csChat/browser/actions/csChatCodeblockActions.ts
@@ -18,7 +18,6 @@ import { ITextModel } from 'vs/editor/common/model';
 import { ILanguageFeaturesService } from 'vs/editor/common/services/languageFeatures';
 import { CopyAction } from 'vs/editor/contrib/clipboard/browser/clipboard';
 import { localize } from 'vs/nls';
-import { CONTEXT_ACCESSIBILITY_MODE_ENABLED } from 'vs/platform/accessibility/common/accessibility';
 import { Action2, MenuId, registerAction2 } from 'vs/platform/actions/common/actions';
 import { IClipboardService } from 'vs/platform/clipboard/common/clipboardService';
 import { ContextKeyExpr } from 'vs/platform/contextkey/common/contextkey';
@@ -29,7 +28,7 @@ import { CHAT_CATEGORY } from 'vs/workbench/contrib/chat/browser/actions/chatAct
 import { IChatWidgetService } from 'vs/workbench/contrib/chat/browser/chat';
 import { ICodeBlockActionContext } from 'vs/workbench/contrib/chat/browser/codeBlockPart';
 import { CONTEXT_IN_CHAT_SESSION, CONTEXT_PROVIDER_EXISTS } from 'vs/workbench/contrib/chat/common/chatContextKeys';
-import { IChatCopyAction, IChatService, IDocumentContext, InteractiveSessionCopyKind } from 'vs/workbench/contrib/chat/common/chatService';
+import { IChatService, IDocumentContext, InteractiveSessionCopyKind } from 'vs/workbench/contrib/chat/common/chatService';
 import { IChatResponseViewModel, isResponseVM } from 'vs/workbench/contrib/chat/common/chatViewModel';
 import { CTX_INLINE_CHAT_VISIBLE } from 'vs/workbench/contrib/inlineChat/common/inlineChat';
 import { insertCell } from 'vs/workbench/contrib/notebook/browser/controller/cellOperations';
@@ -52,7 +51,7 @@ function isResponseFiltered(context: ICodeBlockActionContext) {
 }
 
 function getUsedDocuments(context: ICodeBlockActionContext): IDocumentContext[] | undefined {
-	return isResponseVM(context.element) ? context.element.response.usedContext?.documents : undefined;
+	return isResponseVM(context.element) ? context.element.usedContext?.documents : undefined;
 }
 
 abstract class ChatCodeBlockAction extends Action2 {
@@ -112,9 +111,8 @@ export function registerChatCodeBlockActions() {
 					agentId: context.element.agent?.id,
 					sessionId: context.element.sessionId,
 					requestId: context.element.requestId,
-					action: <IChatCopyAction>{
+					action: {
 						kind: 'copy',
-						responseId: context.element.providerResponseId,
 						codeBlockIndex: context.codeBlockIndex,
 						copyType: InteractiveSessionCopyKind.Toolbar,
 						copiedCharacters: context.code.length,
@@ -150,24 +148,21 @@ export function registerChatCodeBlockActions() {
 		const totalCharacters = editorModel.getValueLength();
 
 		// Report copy to extensions
-		if (context.element.providerResponseId) {
-			const chatService = accessor.get(IChatService);
-			chatService.notifyUserAction({
-				providerId: context.element.providerId,
-				agentId: context.element.agent?.id,
-				sessionId: context.element.sessionId,
-				requestId: context.element.requestId,
-				action: {
-					kind: 'copy',
-					codeBlockIndex: context.codeBlockIndex,
-					responseId: context.element.providerResponseId,
-					copyType: InteractiveSessionCopyKind.Action,
-					copiedText,
-					copiedCharacters: copiedText.length,
-					totalCharacters,
-				}
-			});
-		}
+		const chatService = accessor.get(IChatService);
+		chatService.notifyUserAction({
+			providerId: context.element.providerId,
+			agentId: context.element.agent?.id,
+			sessionId: context.element.sessionId,
+			requestId: context.element.requestId,
+			action: {
+				kind: 'copy',
+				codeBlockIndex: context.codeBlockIndex,
+				copyType: InteractiveSessionCopyKind.Action,
+				copiedText,
+				copiedCharacters: copiedText.length,
+				totalCharacters,
+			}
+		});
 
 		// Copy full cell if no selection, otherwise fall back on normal editor implementation
 		if (noSelection) {
@@ -196,7 +191,7 @@ export function registerChatCodeBlockActions() {
 					when: CONTEXT_IN_CHAT_SESSION,
 				},
 				keybinding: {
-					when: ContextKeyExpr.and(CONTEXT_IN_CHAT_SESSION, CONTEXT_ACCESSIBILITY_MODE_ENABLED),
+					when: CONTEXT_IN_CHAT_SESSION,
 					primary: KeyMod.CtrlCmd | KeyCode.Enter,
 					mac: { primary: KeyMod.WinCtrl | KeyCode.Enter },
 					weight: KeybindingWeight.WorkbenchContrib
@@ -338,7 +333,6 @@ export function registerChatCodeBlockActions() {
 					requestId: context.element.requestId,
 					action: {
 						kind: 'insert',
-						responseId: context.element.providerResponseId!,
 						codeBlockIndex: context.codeBlockIndex,
 						totalCharacters: context.code.length,
 					}
@@ -353,8 +347,8 @@ export function registerChatCodeBlockActions() {
 			super({
 				id: 'workbench.action.chat.insertIntoNewFile',
 				title: {
-					value: localize('interactive.insertIntoNewFile.label', "Insert Into New File"),
-					original: 'Insert Into New File'
+					value: localize('interactive.insertIntoNewFile.label', "Insert into New File"),
+					original: 'Insert into New File'
 				},
 				precondition: CONTEXT_PROVIDER_EXISTS,
 				f1: true,
@@ -387,7 +381,6 @@ export function registerChatCodeBlockActions() {
 					requestId: context.element.requestId,
 					action: {
 						kind: 'insert',
-						responseId: context.element.providerResponseId!,
 						codeBlockIndex: context.codeBlockIndex,
 						totalCharacters: context.code.length,
 						newFile: true
@@ -438,16 +431,10 @@ export function registerChatCodeBlockActions() {
 				keybinding: [{
 					primary: KeyMod.CtrlCmd | KeyMod.Alt | KeyCode.Enter,
 					mac: {
-						primary: KeyMod.WinCtrl | KeyCode.Enter,
+						primary: KeyMod.WinCtrl | KeyMod.Alt | KeyCode.Enter
 					},
 					weight: KeybindingWeight.EditorContrib,
-					when: ContextKeyExpr.and(CONTEXT_IN_CHAT_SESSION, CONTEXT_ACCESSIBILITY_MODE_ENABLED.negate()),
-				},
-				{
-					primary: KeyMod.CtrlCmd | KeyCode.Slash,
-					mac: { primary: KeyMod.WinCtrl | KeyCode.Slash },
-					weight: KeybindingWeight.WorkbenchContrib,
-					when: ContextKeyExpr.and(CONTEXT_IN_CHAT_SESSION, CONTEXT_ACCESSIBILITY_MODE_ENABLED),
+					when: CONTEXT_IN_CHAT_SESSION,
 				}]
 			});
 		}
@@ -489,7 +476,6 @@ export function registerChatCodeBlockActions() {
 					requestId: context.element.requestId,
 					action: {
 						kind: 'runInTerminal',
-						responseId: context.element.providerResponseId!,
 						codeBlockIndex: context.codeBlockIndex,
 						languageId: context.languageId,
 					}
diff --git a/src/vs/workbench/contrib/csChat/browser/actions/csChatCopyActions.ts b/src/vs/workbench/contrib/csChat/browser/actions/csChatCopyActions.ts
index a2e7aa52b62..b679221edce 100644
--- a/src/vs/workbench/contrib/csChat/browser/actions/csChatCopyActions.ts
+++ b/src/vs/workbench/contrib/csChat/browser/actions/csChatCopyActions.ts
@@ -9,6 +9,7 @@ import { Action2, MenuId, registerAction2 } from 'vs/platform/actions/common/act
 import { IClipboardService } from 'vs/platform/clipboard/common/clipboardService';
 import { CHAT_CATEGORY } from 'vs/workbench/contrib/chat/browser/actions/chatActions';
 import { IChatWidgetService } from 'vs/workbench/contrib/chat/browser/chat';
+import { CONTEXT_RESPONSE_FILTERED } from 'vs/workbench/contrib/chat/common/chatContextKeys';
 import { IChatRequestViewModel, IChatResponseViewModel, isRequestVM, isResponseVM } from 'vs/workbench/contrib/chat/common/chatViewModel';
 
 export function registerChatCopyActions() {
@@ -23,7 +24,9 @@ export function registerChatCopyActions() {
 				f1: false,
 				category: CHAT_CATEGORY,
 				menu: {
-					id: MenuId.ChatContext
+					id: MenuId.ChatContext,
+					when: CONTEXT_RESPONSE_FILTERED.toNegated(),
+					group: 'copy',
 				}
 			});
 		}
@@ -35,8 +38,8 @@ export function registerChatCopyActions() {
 			if (widget) {
 				const viewModel = widget.viewModel;
 				const sessionAsText = viewModel?.getItems()
-					.filter((item): item is (IChatRequestViewModel | IChatResponseViewModel) => isRequestVM(item) || isResponseVM(item))
-					.map(stringifyItem)
+					.filter((item): item is (IChatRequestViewModel | IChatResponseViewModel) => isRequestVM(item) || (isResponseVM(item) && !item.errorDetails?.responseIsFiltered))
+					.map(item => stringifyItem(item))
 					.join('\n\n');
 				if (sessionAsText) {
 					clipboardService.writeText(sessionAsText);
@@ -56,7 +59,9 @@ export function registerChatCopyActions() {
 				f1: false,
 				category: CHAT_CATEGORY,
 				menu: {
-					id: MenuId.ChatContext
+					id: MenuId.ChatContext,
+					when: CONTEXT_RESPONSE_FILTERED.toNegated(),
+					group: 'copy',
 				}
 			});
 		}
@@ -68,13 +73,16 @@ export function registerChatCopyActions() {
 			}
 
 			const clipboardService = accessor.get(IClipboardService);
-			const text = stringifyItem(item);
+			const text = stringifyItem(item, false);
 			clipboardService.writeText(text);
 		}
 	});
 }
 
-function stringifyItem(item: IChatRequestViewModel | IChatResponseViewModel): string {
-	return isRequestVM(item) ?
-		`${item.username}: ${item.messageText}` : `${item.username}: ${item.response.asString()}`;
+function stringifyItem(item: IChatRequestViewModel | IChatResponseViewModel, includeName = true): string {
+	if (isRequestVM(item)) {
+		return (includeName ? `${item.username}: ` : '') + item.messageText;
+	} else {
+		return (includeName ? `${item.username}: ` : '') + item.response.asString();
+	}
 }
diff --git a/src/vs/workbench/contrib/csChat/browser/actions/csChatExecuteActions.ts b/src/vs/workbench/contrib/csChat/browser/actions/csChatExecuteActions.ts
index 07776d570a6..817844feb3b 100644
--- a/src/vs/workbench/contrib/csChat/browser/actions/csChatExecuteActions.ts
+++ b/src/vs/workbench/contrib/csChat/browser/actions/csChatExecuteActions.ts
@@ -8,19 +8,15 @@ import { ServicesAccessor } from 'vs/editor/browser/editorExtensions';
 import { localize } from 'vs/nls';
 import { Action2, MenuId, registerAction2 } from 'vs/platform/actions/common/actions';
 import { CHAT_CATEGORY } from 'vs/workbench/contrib/chat/browser/actions/chatActions';
-import { IChatWidget } from 'vs/workbench/contrib/chat/browser/chat';
+import { IChatWidget, IChatWidgetService } from 'vs/workbench/contrib/chat/browser/chat';
 import { CONTEXT_CHAT_INPUT_HAS_TEXT, CONTEXT_CHAT_REQUEST_IN_PROGRESS } from 'vs/workbench/contrib/chat/common/chatContextKeys';
 import { IChatService } from 'vs/workbench/contrib/chat/common/chatService';
 
 export interface IChatExecuteActionContext {
-	widget: IChatWidget;
+	widget?: IChatWidget;
 	inputValue?: string;
 }
 
-export function isExecuteActionContext(thing: unknown): thing is IChatExecuteActionContext {
-	return typeof thing === 'object' && thing !== null && 'widget' in thing;
-}
-
 export class SubmitAction extends Action2 {
 	static readonly ID = 'workbench.action.chat.submit';
 
@@ -44,12 +40,11 @@ export class SubmitAction extends Action2 {
 	}
 
 	run(accessor: ServicesAccessor, ...args: any[]) {
-		const context = args[0];
-		if (!isExecuteActionContext(context)) {
-			return;
-		}
+		const context: IChatExecuteActionContext = args[0];
 
-		context.widget.acceptInput(context.inputValue);
+		const widgetService = accessor.get(IChatWidgetService);
+		const widget = context.widget ?? widgetService.lastFocusedWidget;
+		widget?.acceptInput(context.inputValue);
 	}
 }
 
@@ -76,8 +71,8 @@ export function registerChatExecuteActions() {
 		}
 
 		run(accessor: ServicesAccessor, ...args: any[]) {
-			const context = args[0];
-			if (!isExecuteActionContext(context)) {
+			const context: IChatExecuteActionContext = args[0];
+			if (!context.widget) {
 				return;
 			}
 
diff --git a/src/vs/workbench/contrib/csChat/browser/actions/csChatMoveActions.ts b/src/vs/workbench/contrib/csChat/browser/actions/csChatMoveActions.ts
index fda8281ddc5..e7b68fa51b3 100644
--- a/src/vs/workbench/contrib/csChat/browser/actions/csChatMoveActions.ts
+++ b/src/vs/workbench/contrib/csChat/browser/actions/csChatMoveActions.ts
@@ -6,7 +6,7 @@
 import { localize } from 'vs/nls';
 import { Action2, IAction2Options, MenuId, registerAction2 } from 'vs/platform/actions/common/actions';
 import { ContextKeyExpr } from 'vs/platform/contextkey/common/contextkey';
-import { ServicesAccessor } from 'vs/platform/instantiation/common/instantiation';
+import { IInstantiationService, ServicesAccessor } from 'vs/platform/instantiation/common/instantiation';
 import { ViewAction } from 'vs/workbench/browser/parts/views/viewPane';
 import { ActiveEditorContext } from 'vs/workbench/common/contextkeys';
 import { IViewsService } from 'vs/workbench/common/views';
@@ -21,11 +21,16 @@ import { IChatService } from 'vs/workbench/contrib/chat/common/chatService';
 import { IEditorGroupsService } from 'vs/workbench/services/editor/common/editorGroupsService';
 import { IEditorService } from 'vs/workbench/services/editor/common/editorService';
 
-const getMoveToEditorChatActionDescriptorForViewTitle = (viewId: string, providerId: string): Readonly<IAction2Options> & { viewId: string } => ({
-	id: `workbench.action.chat.${providerId}.openInEditor`,
+enum MoveToNewLocation {
+	Editor = 'Editor',
+	Window = 'Window'
+}
+
+const getMoveToChatActionDescriptorForViewTitle = (viewId: string, providerId: string, moveTo: MoveToNewLocation): Readonly<IAction2Options> & { viewId: string } => ({
+	id: `workbench.action.chat.${providerId}.openIn${moveTo}`,
 	title: {
-		value: localize('chat.openInEditor.label', "Open Session In Editor"),
-		original: 'Open Session In Editor'
+		value: moveTo === MoveToNewLocation.Editor ? localize('chat.openInEditor.label', "Open Session in Editor") : localize('chat.openInNewWindow.label', "Open Session in New Window"),
+		original: moveTo === MoveToNewLocation.Editor ? 'Open Session in Editor' : 'Open Session in New Window',
 	},
 	category: CHAT_CATEGORY,
 	precondition: CONTEXT_PROVIDER_EXISTS,
@@ -39,9 +44,17 @@ const getMoveToEditorChatActionDescriptorForViewTitle = (viewId: string, provide
 });
 
 export function getMoveToEditorAction(viewId: string, providerId: string) {
-	return class MoveToEditorAction extends ViewAction<ChatViewPane> {
+	return getMoveToAction(viewId, providerId, MoveToNewLocation.Editor);
+}
+
+export function getMoveToNewWindowAction(viewId: string, providerId: string) {
+	return getMoveToAction(viewId, providerId, MoveToNewLocation.Window);
+}
+
+export function getMoveToAction(viewId: string, providerId: string, moveTo: MoveToNewLocation) {
+	return class MoveToAction extends ViewAction<ChatViewPane> {
 		constructor() {
-			super(getMoveToEditorChatActionDescriptorForViewTitle(viewId, providerId));
+			super(getMoveToChatActionDescriptorForViewTitle(viewId, providerId, moveTo));
 		}
 
 		async runInView(accessor: ServicesAccessor, view: ChatViewPane) {
@@ -50,41 +63,37 @@ export function getMoveToEditorAction(viewId: string, providerId: string) {
 				return;
 			}
 
+			const editorGroupService = accessor.get(IEditorGroupsService);
+			const instantiationService = accessor.get(IInstantiationService);
 			const editorService = accessor.get(IEditorService);
+			const sessionId = viewModel.sessionId;
 			view.clear();
-			await editorService.openEditor({ resource: ChatEditorInput.getNewEditorUri(), options: <IChatEditorOptions>{ target: { sessionId: viewModel.sessionId }, pinned: true } });
+
+			switch (moveTo) {
+				case (MoveToNewLocation.Editor): {
+					await editorService.openEditor({ resource: ChatEditorInput.getNewEditorUri(), options: <IChatEditorOptions>{ target: { sessionId: viewModel.sessionId }, pinned: true } });
+					break;
+				}
+				case (MoveToNewLocation.Window): {
+					await openInNewWindow(instantiationService, editorGroupService, { target: { sessionId } });
+					break;
+				}
+				default: {
+					throw new Error(`Unexpected move to location : ${moveTo}`);
+				}
+			}
 		}
 	};
 }
 
-async function moveToSidebar(accessor: ServicesAccessor): Promise<void> {
-	const viewsService = accessor.get(IViewsService);
-	const editorService = accessor.get(IEditorService);
-	const chatContribService = accessor.get(IChatContributionService);
-	const editorGroupService = accessor.get(IEditorGroupsService);
-
-	const chatEditorInput = editorService.activeEditor;
-	if (chatEditorInput instanceof ChatEditorInput && chatEditorInput.sessionId && chatEditorInput.providerId) {
-		await editorService.closeEditor({ editor: chatEditorInput, groupId: editorGroupService.activeGroup.id });
-		const viewId = chatContribService.getViewIdForProvider(chatEditorInput.providerId);
-		const view = await viewsService.openView(viewId) as ChatViewPane;
-		view.loadSession(chatEditorInput.sessionId);
-	} else {
-		const chatService = accessor.get(IChatService);
-		const providerId = chatService.getProviderInfos()[0].id;
-		const viewId = chatContribService.getViewIdForProvider(providerId);
-		await viewsService.openView(viewId);
-	}
-}
-
 export function registerMoveActions() {
 	registerAction2(class GlobalMoveToEditorAction extends Action2 {
 		constructor() {
 			super({
 				id: `workbench.action.chat.openInEditor`,
 				title: {
-					value: localize('interactiveSession.openInEditor.label', "Open Session In Editor"),
-					original: 'Open Session In Editor'
+					value: localize('interactiveSession.openInEditor.label', "Open Session in Editor"),
+					original: 'Open Session in Editor'
 				},
 				category: CHAT_CATEGORY,
 				precondition: CONTEXT_PROVIDER_EXISTS,
@@ -93,27 +102,27 @@ export function registerMoveActions() {
 		}
 
 		async run(accessor: ServicesAccessor, ...args: any[]) {
-			const widgetService = accessor.get(IChatWidgetService);
-			const viewService = accessor.get(IViewsService);
-			const editorService = accessor.get(IEditorService);
-			const chatService = accessor.get(IChatService);
+			executeMoveToAction(accessor, MoveToNewLocation.Editor);
+		}
+	});
 
-			const widget = widgetService.lastFocusedWidget;
-			if (!widget || !('viewId' in widget.viewContext)) {
-				const providerId = chatService.getProviderInfos()[0].id;
-				await editorService.openEditor({ resource: ChatEditorInput.getNewEditorUri(), options: <IChatEditorOptions>{ target: { providerId }, pinned: true } });
-				return;
-			}
+	registerAction2(class GlobalMoveToNewWindowAction extends Action2 {
 
-			const viewModel = widget.viewModel;
-			if (!viewModel) {
-				return;
-			}
+		constructor() {
+			super({
+				id: `workbench.action.chat.openInNewWindow`,
+				title: {
+					value: localize('interactiveSession.openInNewWindow.label', "Open Session in New Window"),
+					original: 'Open Session In New Window'
+				},
+				category: CHAT_CATEGORY,
+				precondition: CONTEXT_PROVIDER_EXISTS,
+				f1: true
+			});
+		}
 
-			const sessionId = viewModel.sessionId;
-			const view = await viewService.openView(widget.viewContext.viewId) as ChatViewPane;
-			view.clear();
-			await editorService.openEditor({ resource: ChatEditorInput.getNewEditorUri(), options: <IChatEditorOptions>{ target: { sessionId: sessionId }, pinned: true } });
+		async run(accessor: ServicesAccessor, ...args: any[]) {
+			executeMoveToAction(accessor, MoveToNewLocation.Window);
 		}
 	});
 
@@ -122,8 +131,8 @@ export function registerMoveActions() {
 			super({
 				id: `workbench.action.chat.openInSidebar`,
 				title: {
-					value: localize('interactiveSession.openInSidebar.label', "Open Session In Sidebar"),
-					original: 'Open Session In Sidebar'
+					value: localize('interactiveSession.openInSidebar.label', "Open Session in Side Bar"),
+					original: 'Open Session in Side Bar'
 				},
 				category: CHAT_CATEGORY,
 				precondition: CONTEXT_PROVIDER_EXISTS,
@@ -141,3 +150,80 @@ export function registerMoveActions() {
 		}
 	});
 }
+
+async function executeMoveToAction(accessor: ServicesAccessor, moveTo: MoveToNewLocation) {
+	const widgetService = accessor.get(IChatWidgetService);
+	const viewService = accessor.get(IViewsService);
+	const chatService = accessor.get(IChatService);
+	const editorService = accessor.get(IEditorService);
+	const instantiationService = accessor.get(IInstantiationService);
+	const editorGroupService = accessor.get(IEditorGroupsService);
+
+	const widget = widgetService.lastFocusedWidget;
+	if (!widget || !('viewId' in widget.viewContext)) {
+		const providerId = chatService.getProviderInfos()[0].id;
+
+		switch (moveTo) {
+			case (MoveToNewLocation.Editor): {
+				await editorService.openEditor({ resource: ChatEditorInput.getNewEditorUri(), options: <IChatEditorOptions>{ target: { providerId }, pinned: true } });
+				break;
+			}
+			case (MoveToNewLocation.Window): {
+				await openInNewWindow(instantiationService, editorGroupService, { target: { providerId } });
+				break;
+			}
+			default: {
+				throw new Error(`Unexpected move to location : ${moveTo}`);
+			}
+		}
+		return;
+	}
+
+	const viewModel = widget.viewModel;
+	if (!viewModel) {
+		return;
+	}
+
+	const sessionId = viewModel.sessionId;
+	const view = await viewService.openView(widget.viewContext.viewId) as ChatViewPane;
+	view.clear();
+
+	switch (moveTo) {
+		case (MoveToNewLocation.Editor): {
+			await editorService.openEditor({ resource: ChatEditorInput.getNewEditorUri(), options: <IChatEditorOptions>{ target: { sessionId: sessionId }, pinned: true } });
+			break;
+		}
+		case (MoveToNewLocation.Window): {
+			await openInNewWindow(instantiationService, editorGroupService, { target: { sessionId } });
+		}
+		default: {
+			throw new Error(`Unexpected move to location : ${moveTo}`);
+		}
+	}
+}
+
+async function openInNewWindow(intstantiationService: IInstantiationService, editorGroupService: IEditorGroupsService, options: IChatEditorOptions) {
+	const auxiliaryEditorPart = await editorGroupService.createAuxiliaryEditorPart();
+	const chatEditorInput = intstantiationService.createInstance(ChatEditorInput, ChatEditorInput.getNewEditorUri(), options);
+	await auxiliaryEditorPart.activeGroup.openEditor(chatEditorInput, { pinned: true });
+}
+
+async function moveToSidebar(accessor: ServicesAccessor): Promise<void> {
+	const viewsService = accessor.get(IViewsService);
+	const editorService = accessor.get(IEditorService);
+	const chatContribService = accessor.get(IChatContributionService);
+	const editorGroupService = accessor.get(IEditorGroupsService);
+
+	const chatEditorInput = editorService.activeEditor;
+	if (chatEditorInput instanceof ChatEditorInput && chatEditorInput.sessionId && chatEditorInput.providerId) {
+		await editorService.closeEditor({ editor: chatEditorInput, groupId: editorGroupService.activeGroup.id });
+		const viewId = chatContribService.getViewIdForProvider(chatEditorInput.providerId);
+		const view = await viewsService.openView(viewId) as ChatViewPane;
+		view.loadSession(chatEditorInput.sessionId);
+	} else {
+		const chatService = accessor.get(IChatService);
+		const providerId = chatService.getProviderInfos()[0].id;
+		const viewId = chatContribService.getViewIdForProvider(providerId);
+		await viewsService.openView(viewId);
+	}
+}
diff --git a/src/vs/workbench/contrib/csChat/browser/actions/csChatQuickInputActions.ts b/src/vs/workbench/contrib/csChat/browser/actions/csChatQuickInputActions.ts
index 3525bbea2b9..6007992437b 100644
--- a/src/vs/workbench/contrib/csChat/browser/actions/csChatQuickInputActions.ts
+++ b/src/vs/workbench/contrib/csChat/browser/actions/csChatQuickInputActions.ts
@@ -5,6 +5,7 @@
 
 import { Codicon } from 'vs/base/common/codicons';
 import { KeyCode, KeyMod } from 'vs/base/common/keyCodes';
+import { ICodeEditorService } from 'vs/editor/browser/services/codeEditorService';
 import { Selection } from 'vs/editor/common/core/selection';
 import { localize } from 'vs/nls';
 import { Action2, MenuId, registerAction2 } from 'vs/platform/actions/common/actions';
@@ -13,6 +14,7 @@ import { KeybindingWeight } from 'vs/platform/keybinding/common/keybindingsRegis
 import { CHAT_CATEGORY } from 'vs/workbench/contrib/chat/browser/actions/chatActions';
 import { IQuickChatService, IQuickChatOpenOptions } from 'vs/workbench/contrib/chat/browser/chat';
 import { CONTEXT_PROVIDER_EXISTS } from 'vs/workbench/contrib/chat/common/chatContextKeys';
+import { InlineChatController } from 'vs/workbench/contrib/inlineChat/browser/inlineChatController';
 
 export const ASK_QUICK_QUESTION_ACTION_ID = 'workbench.action.quickchat.toggle';
 export function registerQuickChatActions() {
@@ -67,6 +69,40 @@ export function registerQuickChatActions() {
 			quickChatService.close();
 		}
 	});
+
+	registerAction2(class LaunchInlineChatFromQuickChatAction extends Action2 {
+		constructor() {
+			super({
+				id: 'workbench.action.quickchat.launchInlineChat',
+				title: {
+					value: localize('chat.launchInlineChat.label', "Launch Inline Chat"),
+					original: 'Launch Inline Chat'
+				},
+				f1: false,
+				category: CHAT_CATEGORY
+			});
+		}
+
+		async run(accessor: ServicesAccessor) {
+			const quickChatService = accessor.get(IQuickChatService);
+			const codeEditorService = accessor.get(ICodeEditorService);
+			if (quickChatService.focused) {
+				quickChatService.close();
+			}
+			const codeEditor = codeEditorService.getActiveCodeEditor();
+			if (!codeEditor) {
+				return;
+			}
+
+			const controller = InlineChatController.get(codeEditor);
+			if (!controller) {
+				return;
+			}
+
+			await controller.run();
+			controller.focus();
+		}
+	});
 }
 
 class QuickChatGlobalAction extends Action2 {
diff --git a/src/vs/workbench/contrib/csChat/browser/actions/csChatTitleActions.ts b/src/vs/workbench/contrib/csChat/browser/actions/csChatTitleActions.ts
index 4d9bf1fe75b..24f43dc2200 100644
--- a/src/vs/workbench/contrib/csChat/browser/actions/csChatTitleActions.ts
+++ b/src/vs/workbench/contrib/csChat/browser/actions/csChatTitleActions.ts
@@ -15,7 +15,7 @@ import { KeybindingWeight } from 'vs/platform/keybinding/common/keybindingsRegis
 import { ResourceNotebookCellEdit } from 'vs/workbench/contrib/bulkEdit/browser/bulkCellEdits';
 import { CHAT_CATEGORY } from 'vs/workbench/contrib/chat/browser/actions/chatActions';
 import { IChatWidgetService } from 'vs/workbench/contrib/chat/browser/chat';
-import { CONTEXT_IN_CHAT_INPUT, CONTEXT_IN_CHAT_SESSION, CONTEXT_REQUEST, CONTEXT_RESPONSE, CONTEXT_RESPONSE_FILTERED, CONTEXT_RESPONSE_VOTE } from 'vs/workbench/contrib/chat/common/chatContextKeys';
+import { CONTEXT_CHAT_RESPONSE_SUPPORT_ISSUE_REPORTING, CONTEXT_IN_CHAT_INPUT, CONTEXT_IN_CHAT_SESSION, CONTEXT_REQUEST, CONTEXT_RESPONSE, CONTEXT_RESPONSE_FILTERED, CONTEXT_RESPONSE_VOTE } from 'vs/workbench/contrib/chat/common/chatContextKeys';
 import { IChatService, InteractiveSessionVoteDirection } from 'vs/workbench/contrib/chat/common/chatService';
 import { isRequestVM, isResponseVM } from 'vs/workbench/contrib/chat/common/chatViewModel';
 import { INotebookEditor } from 'vs/workbench/contrib/notebook/browser/notebookBrowser';
@@ -60,7 +60,6 @@ export function registerChatTitleActions() {
 				action: {
 					kind: 'vote',
 					direction: InteractiveSessionVoteDirection.Up,
-					responseId: item.providerResponseId!,
 				}
 			});
 			item.setVote(InteractiveSessionVoteDirection.Up);
@@ -103,13 +102,51 @@ export function registerChatTitleActions() {
 				action: {
 					kind: 'vote',
 					direction: InteractiveSessionVoteDirection.Down,
-					responseId: item.providerResponseId!,
 				}
 			});
 			item.setVote(InteractiveSessionVoteDirection.Down);
 		}
 	});
 
+	registerAction2(class ReportIssueForBugAction extends Action2 {
+		constructor() {
+			super({
+				id: 'workbench.action.chat.reportIssueForBug',
+				title: {
+					value: localize('interactive.reportIssueForBug.label', "Report Issue"),
+					original: 'Report Issue'
+				},
+				f1: false,
+				category: CHAT_CATEGORY,
+				icon: Codicon.report,
+				menu: {
+					id: MenuId.ChatMessageTitle,
+					group: 'navigation',
+					order: 3,
+					when: ContextKeyExpr.and(CONTEXT_CHAT_RESPONSE_SUPPORT_ISSUE_REPORTING, CONTEXT_RESPONSE)
+				}
+			});
+		}
+
+		run(accessor: ServicesAccessor, ...args: any[]) {
+			const item = args[0];
+			if (!isResponseVM(item)) {
+				return;
+			}
+
+			const chatService = accessor.get(IChatService);
+			chatService.notifyUserAction({
+				providerId: item.providerId,
+				agentId: item.agent?.id,
+				sessionId: item.sessionId,
+				requestId: item.requestId,
+				action: {
+					kind: 'bug'
+				}
+			});
+		}
+	});
+
 	registerAction2(class InsertToNotebookAction extends Action2 {
 		constructor() {
 			super({
@@ -222,12 +259,12 @@ export function registerChatTitleActions() {
 				item = widget?.getFocus();
 			}
 
-			const providerRequestId = isRequestVM(item) ? item.providerRequestId :
-				isResponseVM(item) ? item.providerResponseId : undefined;
+			const requestId = isRequestVM(item) ? item.id :
+				isResponseVM(item) ? item.requestId : undefined;
 
-			if (providerRequestId) {
+			if (requestId) {
 				const chatService = accessor.get(IChatService);
-				chatService.removeRequest(item.sessionId, providerRequestId);
+				chatService.removeRequest(item.sessionId, requestId);
 			}
 		}
 	});
diff --git a/src/vs/workbench/contrib/csChat/browser/codeBlockPart.ts b/src/vs/workbench/contrib/csChat/browser/codeBlockPart.ts
index 4bc5d908414..fd5350bf367 100644
--- a/src/vs/workbench/contrib/csChat/browser/codeBlockPart.ts
+++ b/src/vs/workbench/contrib/csChat/browser/codeBlockPart.ts
@@ -167,7 +167,7 @@ export class CodeBlockPart extends Disposable implements ICodeBlockPart {
 			WordHighlighterContribution.get(this.editor)?.restoreViewState(true);
 		}));
 
-		this.textModel = this._register(this.modelService.createModel('', null, undefined));
+		this.textModel = this._register(this.modelService.createModel('', null, undefined, true));
 		this.editor.setModel(this.textModel);
 	}
 
diff --git a/src/vs/workbench/contrib/csChat/browser/contrib/csChatInputEditorContrib.ts b/src/vs/workbench/contrib/csChat/browser/contrib/csChatInputEditorContrib.ts
index 6db8aa47a21..a470b14d1e3 100644
--- a/src/vs/workbench/contrib/csChat/browser/contrib/csChatInputEditorContrib.ts
+++ b/src/vs/workbench/contrib/csChat/browser/contrib/csChatInputEditorContrib.ts
@@ -32,6 +32,7 @@ import { chatSlashCommandBackground, chatSlashCommandForeground } from 'vs/workb
 import { ChatRequestAgentPart, ChatRequestAgentSubcommandPart, ChatRequestSlashCommandPart, ChatRequestTextPart, ChatRequestVariablePart, chatAgentLeader, chatSubcommandLeader, chatVariableLeader } from 'vs/workbench/contrib/chat/common/chatParserTypes';
 import { ChatRequestParser } from 'vs/workbench/contrib/chat/common/chatRequestParser';
 import { IChatService, ISlashCommand } from 'vs/workbench/contrib/chat/common/chatService';
+import { IChatSlashCommandService } from 'vs/workbench/contrib/chat/common/chatSlashCommands';
 import { IChatVariablesService } from 'vs/workbench/contrib/chat/common/chatVariables';
 import { isResponseVM } from 'vs/workbench/contrib/chat/common/chatViewModel';
 import { LifecyclePhase } from 'vs/workbench/services/lifecycle/common/lifecycle';
@@ -49,7 +50,7 @@ class InputEditorDecorations extends Disposable {
 
 	public readonly id = 'inputEditorDecorations';
 
-	private readonly previouslyUsedSlashCommands = new Set<string>();
+	private readonly previouslyUsedAgents = new Set<string>();
 
 	private readonly viewModelDisposables = this._register(new MutableDisposable());
 
@@ -71,16 +72,12 @@ class InputEditorDecorations extends Disposable {
 		this._register(this.widget.inputEditor.onDidChangeModelContent(() => this.updateInputEditorDecorations()));
 		this._register(this.widget.onDidChangeViewModel(() => {
 			this.registerViewModelListeners();
-			this.previouslyUsedSlashCommands.clear();
+			this.previouslyUsedAgents.clear();
 			this.updateInputEditorDecorations();
 		}));
-		this._register(this.chatService.onDidSubmitSlashCommand((e) => {
+		this._register(this.chatService.onDidSubmitAgent((e) => {
 			if (e.sessionId === this.widget.viewModel?.sessionId) {
-				if ('agent' in e) {
-					this.previouslyUsedSlashCommands.add(agentAndCommandToKey(e.agent.id, e.slashCommand.name));
-				} else {
-					this.previouslyUsedSlashCommands.add(e.slashCommand);
-				}
+				this.previouslyUsedAgents.add(agentAndCommandToKey(e.agent.id, e.slashCommand.name));
 			}
 		}));
 
@@ -187,7 +184,7 @@ class InputEditorDecorations extends Disposable {
 		const onlyAgentCommandAndWhitespace = agentPart && agentSubcommandPart && parsedRequest.every(p => p instanceof ChatRequestTextPart && !p.text.trim().length || p instanceof ChatRequestAgentPart || p instanceof ChatRequestAgentSubcommandPart);
 		if (onlyAgentCommandAndWhitespace) {
 			// Agent reference and subcommand with no other text - show the placeholder
-			const isFollowupSlashCommand = this.previouslyUsedSlashCommands.has(agentAndCommandToKey(agentPart.agent.id, agentSubcommandPart.command.name));
+			const isFollowupSlashCommand = this.previouslyUsedAgents.has(agentAndCommandToKey(agentPart.agent.id, agentSubcommandPart.command.name));
 			const shouldRenderFollowupPlaceholder = isFollowupSlashCommand && agentSubcommandPart.command.followupPlaceholder;
 			if (agentSubcommandPart?.command.description) {
 				placeholderDecoration = [{
@@ -210,7 +207,7 @@ class InputEditorDecorations extends Disposable {
 		const onlySlashCommandAndWhitespace = slashCommandPart && parsedRequest.every(p => p instanceof ChatRequestTextPart && !p.text.trim().length || p instanceof ChatRequestSlashCommandPart);
 		if (onlySlashCommandAndWhitespace) {
 			// Command reference with no other text - show the placeholder
-			const isFollowupSlashCommand = this.previouslyUsedSlashCommands.has(slashCommandPart.slashCommand.command);
+			const isFollowupSlashCommand = this.previouslyUsedAgents.has(slashCommandPart.slashCommand.command);
 			const shouldRenderFollowupPlaceholder = isFollowupSlashCommand && slashCommandPart.slashCommand.followupPlaceholder;
 			if (shouldRenderFollowupPlaceholder || slashCommandPart.slashCommand.detail) {
 				placeholderDecoration = [{
@@ -264,15 +261,12 @@ class InputEditorSlashCommandMode extends Disposable {
 		@IChatService private readonly chatService: IChatService
 	) {
 		super();
-		this._register(this.chatService.onDidSubmitSlashCommand(e => {
+		this._register(this.chatService.onDidSubmitAgent(e => {
 			if (this.widget.viewModel?.sessionId !== e.sessionId) {
 				return;
 			}
-			if ('agent' in e) {
-				this.repopulateAgentCommand(e.agent, e.slashCommand);
-			} else {
-				this.repopulateSlashCommand(e.slashCommand);
-			}
+
+			this.repopulateAgentCommand(e.agent, e.slashCommand);
 		}));
 	}
 
@@ -283,20 +277,6 @@ class InputEditorSlashCommandMode extends Disposable {
 			this.widget.inputEditor.setPosition({ lineNumber: 1, column: value.length + 1 });
 		}
 	}
-
-	private async repopulateSlashCommand(slashCommand: string) {
-		const slashCommands = await this.widget.getSlashCommands();
-
-		if (this.widget.inputEditor.getValue().trim().length !== 0) {
-			return;
-		}
-
-		if (slashCommands?.find(c => c.command === slashCommand)?.shouldRepopulate) {
-			const value = `/${slashCommand} `;
-			this.widget.inputEditor.setValue(value);
-			this.widget.inputEditor.setPosition({ lineNumber: 1, column: value.length + 1 });
-		}
-	}
 }
 
 ChatWidget.CONTRIBS.push(InputEditorDecorations, InputEditorSlashCommandMode);
@@ -306,11 +286,12 @@ class SlashCommandCompletions extends Disposable {
 		@ILanguageFeaturesService private readonly languageFeaturesService: ILanguageFeaturesService,
 		@IChatWidgetService private readonly chatWidgetService: IChatWidgetService,
 		@IInstantiationService private readonly instantiationService: IInstantiationService,
+		@IChatSlashCommandService private readonly chatSlashCommandService: IChatSlashCommandService
 	) {
 		super();
 
 		this._register(this.languageFeaturesService.completionProvider.register({ scheme: ChatInputPart.INPUT_SCHEME, hasAccessToAllModels: true }, {
-			_debugDisplayName: 'chatSlashCommand',
+			_debugDisplayName: 'globalSlashCommands',
 			triggerCharacters: ['/'],
 			provideCompletionItems: async (model: ITextModel, _position: Position, _context: CompletionContext, _token: CancellationToken) => {
 				const widget = this.chatWidgetService.getWidgetByInputUri(model.uri);
@@ -329,7 +310,7 @@ class SlashCommandCompletions extends Disposable {
 					return;
 				}
 
-				const slashCommands = await widget.getSlashCommands();
+				const slashCommands = this.chatSlashCommandService.getCommands();
 				if (!slashCommands) {
 					return null;
 				}
@@ -550,6 +531,7 @@ class BuiltinDynamicCompletions extends Disposable {
 							range: { insert, replace },
 							kind: CompletionItemKind.Text,
 							command: { id: SelectAndInsertFileAction.ID, title: SelectAndInsertFileAction.ID, arguments: [{ widget, range }] },
+							sortText: 'z'
 						}
 					]
 				};
@@ -701,7 +683,8 @@ class VariableCompletions extends Disposable {
 						range,
 						insertText: withLeader + ' ',
 						detail: v.description,
-						kind: CompletionItemKind.Text, // The icons are disabled here anyway,
+						kind: CompletionItemKind.Text, // The icons are disabled here anyway
+						sortText: 'z'
 					};
 				});
 
diff --git a/src/vs/workbench/contrib/csChat/browser/csChat.contribution.ts b/src/vs/workbench/contrib/csChat/browser/csChat.contribution.ts
index cbe23536b18..b316f8d5dfc 100644
--- a/src/vs/workbench/contrib/csChat/browser/csChat.contribution.ts
+++ b/src/vs/workbench/contrib/csChat/browser/csChat.contribution.ts
@@ -18,7 +18,7 @@ import { EditorExtensions, IEditorFactoryRegistry } from 'vs/workbench/common/ed
 import { registerChatActions } from 'vs/workbench/contrib/chat/browser/actions/chatActions';
 import { registerChatCodeBlockActions } from 'vs/workbench/contrib/chat/browser/actions/chatCodeblockActions';
 import { registerChatCopyActions } from 'vs/workbench/contrib/chat/browser/actions/chatCopyActions';
-import { registerChatExecuteActions } from 'vs/workbench/contrib/chat/browser/actions/chatExecuteActions';
+import { IChatExecuteActionContext, SubmitAction, registerChatExecuteActions } from 'vs/workbench/contrib/chat/browser/actions/chatExecuteActions';
 import { registerQuickChatActions } from 'vs/workbench/contrib/chat/browser/actions/chatQuickInputActions';
 import { registerChatTitleActions } from 'vs/workbench/contrib/chat/browser/actions/chatTitleActions';
 import { registerChatExportActions } from 'vs/workbench/contrib/chat/browser/actions/chatImportExport';
@@ -45,7 +45,7 @@ import { ChatAccessibilityService } from 'vs/workbench/contrib/chat/browser/chat
 import { ICodeEditorService } from 'vs/editor/browser/services/codeEditorService';
 import { AccessibilityVerbositySettingId, AccessibleViewProviderId } from 'vs/workbench/contrib/accessibility/browser/accessibilityConfiguration';
 import { ChatWelcomeMessageModel } from 'vs/workbench/contrib/chat/common/chatModel';
-import { IMarkdownString } from 'vs/base/common/htmlContent';
+import { IMarkdownString, MarkdownString, isMarkdownString } from 'vs/base/common/htmlContent';
 import { ChatProviderService, IChatProviderService } from 'vs/workbench/contrib/chat/common/chatProvider';
 import { ChatSlashCommandService, IChatSlashCommandService } from 'vs/workbench/contrib/chat/common/chatSlashCommands';
 import { alertFocusChange } from 'vs/workbench/contrib/accessibility/browser/accessibilityContributions';
@@ -56,6 +56,8 @@ import { registerChatFileTreeActions } from 'vs/workbench/contrib/chat/browser/a
 import { QuickChatService } from 'vs/workbench/contrib/chat/browser/chatQuick';
 import { ChatAgentService, IChatAgentService } from 'vs/workbench/contrib/chat/common/chatAgents';
 import { ChatVariablesService } from 'vs/workbench/contrib/chat/browser/chatVariables';
+import { chatAgentLeader, chatSubcommandLeader } from 'vs/workbench/contrib/chat/common/chatParserTypes';
+import { CancellationToken } from 'vs/base/common/cancellation';
 
 // Register configuration
 const configurationRegistry = Registry.as<IConfigurationRegistry>(ConfigurationExtensions.Configuration);
@@ -221,16 +223,60 @@ class ChatSlashStaticSlashCommandsContribution extends Disposable {
 	constructor(
 		@IChatSlashCommandService slashCommandService: IChatSlashCommandService,
 		@ICommandService commandService: ICommandService,
+		@IChatAgentService chatAgentService: IChatAgentService,
 	) {
 		super();
 		this._store.add(slashCommandService.registerSlashCommand({
 			command: 'clear',
 			detail: nls.localize('clear', "Clear the session"),
-			sortText: 'z_clear',
+			sortText: 'z2_clear',
 			executeImmediately: true
 		}, async () => {
 			commandService.executeCommand(ACTION_ID_CLEAR_CHAT);
 		}));
+		this._store.add(slashCommandService.registerSlashCommand({
+			command: 'help',
+			detail: '',
+			sortText: 'z1_help',
+			executeImmediately: true
+		}, async (prompt, progress) => {
+			const defaultAgent = chatAgentService.getDefaultAgent();
+			const agents = chatAgentService.getAgents();
+			if (defaultAgent?.metadata.helpTextPrefix) {
+				if (isMarkdownString(defaultAgent.metadata.helpTextPrefix)) {
+					progress.report({ content: defaultAgent.metadata.helpTextPrefix, kind: 'markdownContent' });
+				} else {
+					progress.report({ content: defaultAgent.metadata.helpTextPrefix, kind: 'content' });
+				}
+				progress.report({ content: '\n\n', kind: 'content' });
+			}
+
+			const agentText = (await Promise.all(agents
+				.filter(a => a.id !== defaultAgent?.id)
+				.map(async a => {
+					const agentWithLeader = `${chatAgentLeader}${a.id}`;
+					const actionArg: IChatExecuteActionContext = { inputValue: `${agentWithLeader} ${a.metadata.sampleRequest}` };
+					const urlSafeArg = encodeURIComponent(JSON.stringify(actionArg));
+					const agentLine = `* [\`${agentWithLeader}\`](command:${SubmitAction.ID}?${urlSafeArg}) - ${a.metadata.description}`;
+					const commands = await a.provideSlashCommands(CancellationToken.None);
+					const commandText = commands.map(c => {
+						const actionArg: IChatExecuteActionContext = { inputValue: `${agentWithLeader} ${chatSubcommandLeader}${c.name} ${c.sampleRequest ?? ''}` };
+						const urlSafeArg = encodeURIComponent(JSON.stringify(actionArg));
+						return `\t* [\`${chatSubcommandLeader}${c.name}\`](command:${SubmitAction.ID}?${urlSafeArg}) - ${c.description}`;
+					}).join('\n');
+
+					return agentLine + '\n' + commandText;
+				}))).join('\n');
+			progress.report({ content: new MarkdownString(agentText, { isTrusted: { enabledCommands: [SubmitAction.ID] } }), kind: 'markdownContent' });
+			if (defaultAgent?.metadata.helpTextPostfix) {
+				progress.report({ content: '\n\n', kind: 'content' });
+				if (isMarkdownString(defaultAgent.metadata.helpTextPostfix)) {
+					progress.report({ content: defaultAgent.metadata.helpTextPostfix, kind: 'markdownContent' });
+				} else {
+					progress.report({ content: defaultAgent.metadata.helpTextPostfix, kind: 'content' });
+				}
+			}
+		}));
 	}
 }
 
diff --git a/src/vs/workbench/contrib/csChat/browser/csChat.ts b/src/vs/workbench/contrib/csChat/browser/csChat.ts
index ee80bfeacb9..3df1e83af19 100644
--- a/src/vs/workbench/contrib/csChat/browser/csChat.ts
+++ b/src/vs/workbench/contrib/csChat/browser/csChat.ts
@@ -3,14 +3,13 @@
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
 
-import { ICodeEditor } from 'vs/editor/browser/editorBrowser';
-import { ISlashCommand } from 'vs/workbench/contrib/chat/common/chatService';
-import { IChatRequestViewModel, IChatResponseViewModel, IChatViewModel, IChatWelcomeMessageViewModel } from 'vs/workbench/contrib/chat/common/chatViewModel';
 import { Event } from 'vs/base/common/event';
 import { URI } from 'vs/base/common/uri';
+import { ICodeEditor } from 'vs/editor/browser/editorBrowser';
+import { Selection } from 'vs/editor/common/core/selection';
 import { createDecorator } from 'vs/platform/instantiation/common/instantiation';
 import { IChatWidgetContrib } from 'vs/workbench/contrib/chat/browser/chatWidget';
-import { Selection } from 'vs/editor/common/core/selection';
+import { IChatRequestViewModel, IChatResponseViewModel, IChatViewModel, IChatWelcomeMessageViewModel } from 'vs/workbench/contrib/chat/common/chatViewModel';
 
 export const IChatWidgetService = createDecorator<IChatWidgetService>('chatWidgetService');
 export const IQuickChatService = createDecorator<IQuickChatService>('quickChatService');
@@ -39,6 +38,7 @@ export interface IQuickChatService {
 	readonly _serviceBrand: undefined;
 	readonly onDidClose: Event<void>;
 	readonly enabled: boolean;
+	readonly focused: boolean;
 	toggle(providerId?: string, options?: IQuickChatOpenOptions): void;
 	focus(): void;
 	open(providerId?: string, options?: IQuickChatOpenOptions): void;
@@ -120,7 +120,6 @@ export interface IChatWidget {
 	focusLastMessage(): void;
 	focusInput(): void;
 	hasInputFocus(): boolean;
-	getSlashCommands(): Promise<ISlashCommand[] | undefined>;
 	getCodeBlockInfoForEditor(uri: URI): IChatCodeBlockInfo | undefined;
 	getCodeBlockInfosForResponse(response: IChatResponseViewModel): IChatCodeBlockInfo[];
 	getFileTreeInfosForResponse(response: IChatResponseViewModel): IChatFileTreeInfo[];
diff --git a/src/vs/workbench/contrib/csChat/browser/csChatAccessibilityService.ts b/src/vs/workbench/contrib/csChat/browser/csChatAccessibilityService.ts
index b7173483cd1..1a19c1d3850 100644
--- a/src/vs/workbench/contrib/csChat/browser/csChatAccessibilityService.ts
+++ b/src/vs/workbench/contrib/csChat/browser/csChatAccessibilityService.ts
@@ -7,48 +7,60 @@ import { status } from 'vs/base/browser/ui/aria/aria';
 import { RunOnceScheduler } from 'vs/base/common/async';
 import { Disposable, IDisposable } from 'vs/base/common/lifecycle';
 import { AudioCue, IAudioCueService } from 'vs/platform/audioCues/browser/audioCueService';
+import { IInstantiationService } from 'vs/platform/instantiation/common/instantiation';
 import { IChatAccessibilityService } from 'vs/workbench/contrib/chat/browser/chat';
 import { IChatResponseViewModel } from 'vs/workbench/contrib/chat/common/chatViewModel';
 
-const CHAT_RESPONSE_PENDING_AUDIO_CUE_LOOP_MS = 5000;
-const CHAT_RESPONSE_PENDING_ALLOWANCE_MS = 4000;
 export class ChatAccessibilityService extends Disposable implements IChatAccessibilityService {
 
 	declare readonly _serviceBrand: undefined;
 
-	private _pendingCueMap: Map<number, IDisposable | undefined> = new Map();
+	private _pendingCueMap: Map<number, AudioCueScheduler> = new Map();
 
-	private _runOnceScheduler: RunOnceScheduler;
-	private _lastResponse: string | undefined;
 	private _requestId: number = 0;
 
-	constructor(@IAudioCueService private readonly _audioCueService: IAudioCueService) {
+	constructor(@IAudioCueService private readonly _audioCueService: IAudioCueService, @IInstantiationService private readonly _instantiationService: IInstantiationService) {
 		super();
-		this._register(this._runOnceScheduler = new RunOnceScheduler(() => {
-			this._pendingCueMap.set(this._requestId, this._audioCueService.playAudioCueLoop(AudioCue.chatResponsePending, CHAT_RESPONSE_PENDING_AUDIO_CUE_LOOP_MS));
-		}, CHAT_RESPONSE_PENDING_ALLOWANCE_MS));
 	}
 	acceptRequest(): number {
 		this._requestId++;
 		this._audioCueService.playAudioCue(AudioCue.chatRequestSent, { allowManyInParallel: true });
-		this._runOnceScheduler.schedule();
+		this._pendingCueMap.set(this._requestId, this._register(this._instantiationService.createInstance(AudioCueScheduler)));
 		return this._requestId;
 	}
 	acceptResponse(response: IChatResponseViewModel | string | undefined, requestId: number): void {
 		this._pendingCueMap.get(requestId)?.dispose();
 		this._pendingCueMap.delete(requestId);
 		const isPanelChat = typeof response !== 'string';
-		this._runOnceScheduler?.cancel();
 		const responseContent = typeof response === 'string' ? response : response?.response.asString();
-		if (this._lastResponse === responseContent) {
-			return;
-		}
 		this._audioCueService.playAudioCue(AudioCue.chatResponseReceived, { allowManyInParallel: true });
 		if (!response) {
 			return;
 		}
 		const errorDetails = isPanelChat && response.errorDetails ? ` ${response.errorDetails.message}` : '';
-		this._lastResponse = responseContent;
 		status(responseContent + errorDetails);
 	}
 }
+
+const CHAT_RESPONSE_PENDING_AUDIO_CUE_LOOP_MS = 5000;
+const CHAT_RESPONSE_PENDING_ALLOWANCE_MS = 4000;
+/**
+ * Schedules an audio cue to play when a chat response is pending for too long.
+ */
+class AudioCueScheduler extends Disposable {
+	private _scheduler: RunOnceScheduler;
+	private _audioCueLoop: IDisposable | undefined;
+	constructor(@IAudioCueService private readonly _audioCueService: IAudioCueService) {
+		super();
+		this._scheduler = new RunOnceScheduler(() => {
+			this._audioCueLoop = this._audioCueService.playAudioCueLoop(AudioCue.chatResponsePending, CHAT_RESPONSE_PENDING_AUDIO_CUE_LOOP_MS);
+		}, CHAT_RESPONSE_PENDING_ALLOWANCE_MS);
+		this._scheduler.schedule();
+	}
+	override dispose(): void {
+		super.dispose();
+		this._audioCueLoop?.dispose();
+		this._scheduler.cancel();
+		this._scheduler.dispose();
+	}
+}
diff --git a/src/vs/workbench/contrib/csChat/browser/csChatContributionServiceImpl.ts b/src/vs/workbench/contrib/csChat/browser/csChatContributionServiceImpl.ts
index 37ac18570a3..78ff2e9fa61 100644
--- a/src/vs/workbench/contrib/csChat/browser/csChatContributionServiceImpl.ts
+++ b/src/vs/workbench/contrib/csChat/browser/csChatContributionServiceImpl.ts
@@ -15,7 +15,7 @@ import { IWorkbenchContribution, IWorkbenchContributionsRegistry, Extensions as
 import { IViewContainersRegistry, IViewDescriptor, IViewsRegistry, ViewContainer, ViewContainerLocation, Extensions as ViewExtensions } from 'vs/workbench/common/views';
 import { getHistoryAction, getOpenChatEditorAction } from 'vs/workbench/contrib/chat/browser/actions/chatActions';
 import { getClearAction } from 'vs/workbench/contrib/chat/browser/actions/chatClearActions';
-import { getMoveToEditorAction } from 'vs/workbench/contrib/chat/browser/actions/chatMoveActions';
+import { getMoveToEditorAction, getMoveToNewWindowAction } from 'vs/workbench/contrib/chat/browser/actions/chatMoveActions';
 import { getQuickChatActionForProvider } from 'vs/workbench/contrib/chat/browser/actions/chatQuickInputActions';
 import { CHAT_SIDEBAR_PANEL_ID, ChatViewPane, IChatViewOptions } from 'vs/workbench/contrib/chat/browser/chatViewPane';
 import { IChatContributionService, IChatProviderContribution, IRawChatProviderContribution } from 'vs/workbench/contrib/chat/common/chatContributionService';
@@ -137,6 +137,7 @@ export class ChatExtensionPointHandler implements IWorkbenchContribution {
 		disposables.add(registerAction2(getHistoryAction(viewId, providerDescriptor.id)));
 		disposables.add(registerAction2(getClearAction(viewId, providerDescriptor.id)));
 		disposables.add(registerAction2(getMoveToEditorAction(viewId, providerDescriptor.id)));
+		disposables.add(registerAction2(getMoveToNewWindowAction(viewId, providerDescriptor.id)));
 
 		// "Open Chat" Actions
 		disposables.add(registerAction2(getOpenChatEditorAction(providerDescriptor.id, providerDescriptor.label, providerDescriptor.when)));
diff --git a/src/vs/workbench/contrib/csChat/browser/csChatEditorInput.ts b/src/vs/workbench/contrib/csChat/browser/csChatEditorInput.ts
index cad8d9fddcc..ed7152d1d44 100644
--- a/src/vs/workbench/contrib/csChat/browser/csChatEditorInput.ts
+++ b/src/vs/workbench/contrib/csChat/browser/csChatEditorInput.ts
@@ -9,7 +9,6 @@ import { Disposable, toDisposable } from 'vs/base/common/lifecycle';
 import { Schemas } from 'vs/base/common/network';
 import { URI } from 'vs/base/common/uri';
 import * as nls from 'vs/nls';
-import { IEditorModel } from 'vs/platform/editor/common/editor';
 import { IInstantiationService } from 'vs/platform/instantiation/common/instantiation';
 import { EditorInputCapabilities, IEditorSerializer, IUntypedEditorInput } from 'vs/workbench/common/editor';
 import { EditorInput } from 'vs/workbench/common/editor/editorInput';
@@ -114,7 +113,7 @@ export class ChatEditorInput extends EditorInput {
 	}
 }
 
-export class ChatEditorModel extends Disposable implements IEditorModel {
+export class ChatEditorModel extends Disposable {
 	private _onWillDispose = this._register(new Emitter<void>());
 	readonly onWillDispose = this._onWillDispose.event;
 
diff --git a/src/vs/workbench/contrib/csChat/browser/csChatInputPart.ts b/src/vs/workbench/contrib/csChat/browser/csChatInputPart.ts
index a9c25488326..eb115500062 100644
--- a/src/vs/workbench/contrib/csChat/browser/csChatInputPart.ts
+++ b/src/vs/workbench/contrib/csChat/browser/csChatInputPart.ts
@@ -116,12 +116,14 @@ export class ChatInputPart extends Disposable implements IHistoryNavigationWidge
 		return localize('chatInput', "Chat Input");
 	}
 
-	setState(providerId: string, inputValue: string): void {
+	setState(providerId: string, inputValue: string | undefined): void {
 		this.providerId = providerId;
 		const history = this.historyService.getHistory(providerId);
 		this.history = new HistoryNavigator(history, 50);
 
-		this.setValue(inputValue);
+		if (typeof inputValue === 'string') {
+			this.setValue(inputValue);
+		}
 	}
 
 	get element(): HTMLElement {
diff --git a/src/vs/workbench/contrib/csChat/browser/csChatListRenderer.ts b/src/vs/workbench/contrib/csChat/browser/csChatListRenderer.ts
index c7f1c97fd14..26b1ab5ebab 100644
--- a/src/vs/workbench/contrib/csChat/browser/csChatListRenderer.ts
+++ b/src/vs/workbench/contrib/csChat/browser/csChatListRenderer.ts
@@ -16,7 +16,7 @@ import { ICompressibleTreeRenderer } from 'vs/base/browser/ui/tree/objectTree';
 import { IAsyncDataSource, ITreeNode, ITreeRenderer } from 'vs/base/browser/ui/tree/tree';
 import { IAction } from 'vs/base/common/actions';
 import { distinct } from 'vs/base/common/arrays';
-import { IntervalTimer, disposableTimeout } from 'vs/base/common/async';
+import { disposableTimeout } from 'vs/base/common/async';
 import { Codicon } from 'vs/base/common/codicons';
 import { Emitter, Event } from 'vs/base/common/event';
 import { FuzzyScore } from 'vs/base/common/filters';
@@ -54,10 +54,10 @@ import { convertParsedRequestToMarkdown, reduceInlineContentReferences, walkTree
 import { ChatEditorOptions } from 'vs/workbench/contrib/chat/browser/chatOptions';
 import { CodeBlockPart, ICodeBlockData, ICodeBlockPart } from 'vs/workbench/contrib/chat/browser/codeBlockPart';
 import { IChatAgentMetadata } from 'vs/workbench/contrib/chat/common/chatAgents';
-import { CONTEXT_REQUEST, CONTEXT_RESPONSE, CONTEXT_RESPONSE_FILTERED, CONTEXT_RESPONSE_HAS_PROVIDER_ID, CONTEXT_RESPONSE_VOTE } from 'vs/workbench/contrib/chat/common/chatContextKeys';
-import { IPlaceholderMarkdownString } from 'vs/workbench/contrib/chat/common/chatModel';
+import { CONTEXT_CHAT_RESPONSE_SUPPORT_ISSUE_REPORTING, CONTEXT_REQUEST, CONTEXT_RESPONSE, CONTEXT_RESPONSE_FILTERED, CONTEXT_RESPONSE_VOTE } from 'vs/workbench/contrib/chat/common/chatContextKeys';
+import { IChatProgressResponseContent } from 'vs/workbench/contrib/chat/common/chatModel';
 import { chatAgentLeader, chatSubcommandLeader } from 'vs/workbench/contrib/chat/common/chatParserTypes';
-import { IChatContentReference, IChatReplyFollowup, IChatResponseProgressFileTreeData, IChatService, ISlashCommand, InteractiveSessionVoteDirection } from 'vs/workbench/contrib/chat/common/chatService';
+import { IChatContentInlineReference, IChatContentReference, IChatReplyFollowup, IChatResponseProgressFileTreeData, IChatService, InteractiveSessionVoteDirection } from 'vs/workbench/contrib/chat/common/chatService';
 import { IChatResponseMarkdownRenderData, IChatResponseRenderData, IChatResponseViewModel, IChatWelcomeMessageViewModel, isRequestVM, isResponseVM, isWelcomeVM } from 'vs/workbench/contrib/chat/common/chatViewModel';
 import { IWordCountResult, getNWords } from 'vs/workbench/contrib/chat/common/chatWordCounter';
 import { createFileIconThemableTreeContainerScope } from 'vs/workbench/contrib/files/browser/views/explorerView';
@@ -68,11 +68,12 @@ const $ = dom.$;
 
 interface IChatListItemTemplate {
 	readonly rowContainer: HTMLElement;
-	readonly titleToolbar: MenuWorkbenchToolBar;
+	readonly titleToolbar?: MenuWorkbenchToolBar;
 	readonly avatarContainer: HTMLElement;
 	readonly agentAvatarContainer: HTMLElement;
 	readonly username: HTMLElement;
 	readonly detail: HTMLElement;
+	readonly progressSteps: HTMLElement;
 	readonly value: HTMLElement;
 	readonly referencesListContainer: HTMLElement;
 	readonly contextKeyService: IContextKeyService;
@@ -89,11 +90,12 @@ const forceVerboseLayoutTracing = false;
 
 export interface IChatRendererDelegate {
 	getListLength(): number;
-	getSlashCommands(): ISlashCommand[];
 }
 
 export interface IChatListItemRendererOptions {
 	readonly renderStyle?: 'default' | 'compact';
+	readonly noHeader?: boolean;
+	readonly noPadding?: boolean;
 }
 
 export class ChatListItemRenderer extends Disposable implements ITreeRenderer<ChatTreeItem, FuzzyScore, IChatListItemTemplate> {
@@ -211,7 +213,7 @@ export class ChatListItemRenderer extends Disposable implements ITreeRenderer<Ch
 	}
 
 	layout(width: number): void {
-		this._currentLayoutWidth = width - 40; // TODO Padding
+		this._currentLayoutWidth = width - (this.rendererOptions.noPadding ? 0 : 40); // padding
 		this._editorPool.inUse.forEach(editor => {
 			editor.layout(this._currentLayoutWidth);
 		});
@@ -223,6 +225,9 @@ export class ChatListItemRenderer extends Disposable implements ITreeRenderer<Ch
 		if (this.rendererOptions.renderStyle === 'compact') {
 			rowContainer.classList.add('interactive-item-compact');
 		}
+		if (this.rendererOptions.noPadding) {
+			rowContainer.classList.add('no-padding');
+		}
 		const header = dom.append(rowContainer, $('.header'));
 		const user = dom.append(header, $('.user'));
 		const avatarContainer = dom.append(user, $('.avatar-container'));
@@ -231,32 +236,39 @@ export class ChatListItemRenderer extends Disposable implements ITreeRenderer<Ch
 		const detailContainer = dom.append(user, $('span.detail-container'));
 		const detail = dom.append(detailContainer, $('span.detail'));
 		dom.append(detailContainer, $('span.chat-animated-ellipsis'));
+		const progressSteps = dom.append(rowContainer, $('.progress-steps'));
 		const referencesListContainer = dom.append(rowContainer, $('.referencesListContainer'));
 		const value = dom.append(rowContainer, $('.value'));
 		const elementDisposables = new DisposableStore();
 
 		const contextKeyService = templateDisposables.add(this.contextKeyService.createScoped(rowContainer));
 		const scopedInstantiationService = this.instantiationService.createChild(new ServiceCollection([IContextKeyService, contextKeyService]));
-		const titleToolbar = templateDisposables.add(scopedInstantiationService.createInstance(MenuWorkbenchToolBar, header, MenuId.ChatMessageTitle, {
-			menuOptions: {
-				shouldForwardArgs: true
-			},
-			actionViewItemProvider: (action: IAction, options: IActionViewItemOptions) => {
-				if (action instanceof MenuItemAction && (action.item.id === 'workbench.action.chat.voteDown' || action.item.id === 'workbench.action.chat.voteUp')) {
-					return scopedInstantiationService.createInstance(ChatVoteButton, action, options as IMenuEntryActionViewItemOptions);
-				}
-
-				return undefined;
-			}
-		}));
-
+		let titleToolbar: MenuWorkbenchToolBar | undefined;
+		if (this.rendererOptions.noHeader) {
+			header.classList.add('hidden');
+		} else {
+			titleToolbar = templateDisposables.add(scopedInstantiationService.createInstance(MenuWorkbenchToolBar, header, MenuId.ChatMessageTitle, {
+				menuOptions: {
+					shouldForwardArgs: true
+				},
+				actionViewItemProvider: (action: IAction, options: IActionViewItemOptions) => {
+					if (action instanceof MenuItemAction && (action.item.id === 'workbench.action.chat.voteDown' || action.item.id === 'workbench.action.chat.voteUp')) {
+						return scopedInstantiationService.createInstance(ChatVoteButton, action, options as IMenuEntryActionViewItemOptions);
+					}
 
-		const template: IChatListItemTemplate = { avatarContainer, agentAvatarContainer, username, detail, referencesListContainer, value, rowContainer, elementDisposables, titleToolbar, templateDisposables, contextKeyService };
+					return undefined;
+				}
+			}));
+		}
+		const template: IChatListItemTemplate = { avatarContainer, agentAvatarContainer, username, detail, progressSteps, referencesListContainer, value, rowContainer, elementDisposables, titleToolbar, templateDisposables, contextKeyService };
 		return template;
 	}
 
-	renderElement(node: ITreeNode<ChatTreeItem, FuzzyScore>, index: number, templateData: IChatListItemTemplate, height?: number): void {
-		const { element } = node;
+	renderElement(node: ITreeNode<ChatTreeItem, FuzzyScore>, index: number, templateData: IChatListItemTemplate): void {
+		this.renderChatTreeItem(node.element, index, templateData);
+	}
+
+	renderChatTreeItem(element: ChatTreeItem, index: number, templateData: IChatListItemTemplate): void {
 		const kind = isRequestVM(element) ? 'request' :
 			isResponseVM(element) ? 'response' :
 				'welcome';
@@ -264,14 +276,16 @@ export class ChatListItemRenderer extends Disposable implements ITreeRenderer<Ch
 
 		CONTEXT_RESPONSE.bindTo(templateData.contextKeyService).set(isResponseVM(element));
 		CONTEXT_REQUEST.bindTo(templateData.contextKeyService).set(isRequestVM(element));
-		CONTEXT_RESPONSE_HAS_PROVIDER_ID.bindTo(templateData.contextKeyService).set(isResponseVM(element) && !!element.providerResponseId);
 		if (isResponseVM(element)) {
+			CONTEXT_CHAT_RESPONSE_SUPPORT_ISSUE_REPORTING.bindTo(templateData.contextKeyService).set(!!element.agent?.metadata.supportIssueReporting);
 			CONTEXT_RESPONSE_VOTE.bindTo(templateData.contextKeyService).set(element.vote === InteractiveSessionVoteDirection.Up ? 'up' : element.vote === InteractiveSessionVoteDirection.Down ? 'down' : '');
 		} else {
 			CONTEXT_RESPONSE_VOTE.bindTo(templateData.contextKeyService).set('');
 		}
 
-		templateData.titleToolbar.context = element;
+		if (templateData.titleToolbar) {
+			templateData.titleToolbar.context = element;
+		}
 
 		const isFiltered = !!(isResponseVM(element) && element.errorDetails?.responseIsFiltered);
 		CONTEXT_RESPONSE_FILTERED.bindTo(templateData.contextKeyService).set(isFiltered);
@@ -282,11 +296,14 @@ export class ChatListItemRenderer extends Disposable implements ITreeRenderer<Ch
 		templateData.rowContainer.classList.toggle('filtered-response', isFiltered);
 		templateData.rowContainer.classList.toggle('show-progress', isResponseVM(element) && !element.isComplete);
 		templateData.username.textContent = element.username;
-		this.renderAvatar(element, templateData);
+		if (!this.rendererOptions.noHeader) {
+			this.renderAvatar(element, templateData);
+		}
 
 		dom.clearNode(templateData.detail);
 		if (isResponseVM(element)) {
-			this.renderProgressMessage(element, templateData);
+			this.renderDetail(element, templateData);
+			this.renderProgressSteps(element, templateData);
 		}
 
 		// Do a progressive render if
@@ -299,7 +316,7 @@ export class ChatListItemRenderer extends Disposable implements ITreeRenderer<Ch
 			this.traceLayout('renderElement', `start progressive render ${kind}, index=${index}`);
 
 			const progressiveRenderingDisposables = templateData.elementDisposables.add(new DisposableStore());
-			const timer = templateData.elementDisposables.add(new IntervalTimer());
+			const timer = templateData.elementDisposables.add(new dom.WindowIntervalTimer());
 			const runProgressiveRender = (initial?: boolean) => {
 				try {
 					if (this.doNextProgressiveRender(element, index, templateData, !!initial, progressiveRenderingDisposables)) {
@@ -311,7 +328,7 @@ export class ChatListItemRenderer extends Disposable implements ITreeRenderer<Ch
 					throw err;
 				}
 			};
-			timer.cancelAndSet(runProgressiveRender, 50);
+			timer.cancelAndSet(runProgressiveRender, 50, dom.getWindow(templateData.rowContainer));
 			runProgressiveRender(true);
 		} else if (isResponseVM(element)) {
 			const renderableResponse = reduceInlineContentReferences(element.response.value);
@@ -320,13 +337,13 @@ export class ChatListItemRenderer extends Disposable implements ITreeRenderer<Ch
 			const markdown = 'kind' in element.message ?
 				element.message.message :
 				convertParsedRequestToMarkdown(element.message);
-			this.basicRenderElement([new MarkdownString(markdown)], element, index, templateData);
+			this.basicRenderElement([{ content: new MarkdownString(markdown), kind: 'markdownContent' }], element, index, templateData);
 		} else {
-			this.renderWelcomeMessage(element, templateData, height);
+			this.renderWelcomeMessage(element, templateData);
 		}
 	}
 
-	private renderProgressMessage(element: IChatResponseViewModel, templateData: IChatListItemTemplate): void {
+	private renderDetail(element: IChatResponseViewModel, templateData: IChatListItemTemplate): void {
 		let progressMsg: string = '';
 		if (element.agent && !element.agent.metadata.isDefault) {
 			let usingMsg = chatAgentLeader + element.agent.id;
@@ -351,6 +368,20 @@ export class ChatListItemRenderer extends Disposable implements ITreeRenderer<Ch
 		}
 	}
 
+	private renderProgressSteps(element: IChatResponseViewModel, templateData: IChatListItemTemplate): void {
+		dom.clearNode(templateData.progressSteps);
+		if (element.response.value.length) {
+			return;
+		}
+
+		element.progressMessages.forEach((msg, index) => {
+			const last = index === element.progressMessages.length - 1;
+			const icon = last ? ThemeIcon.modify(Codicon.sync, 'spin') : Codicon.check;
+			const step = dom.$('.progress-step', undefined, renderIcon(icon), dom.$('span.progress-step-message', undefined, msg.content));
+			templateData.progressSteps.appendChild(step);
+		});
+	}
+
 	private renderAvatar(element: ChatTreeItem, templateData: IChatListItemTemplate): void {
 		if (element.avatarIconUri) {
 			const avatarImgIcon = dom.$<HTMLImageElement>('img.icon');
@@ -401,23 +432,25 @@ export class ChatListItemRenderer extends Disposable implements ITreeRenderer<Ch
 		}
 	}
 
-	private basicRenderElement(value: ReadonlyArray<IMarkdownString | IChatResponseProgressFileTreeData>, element: ChatTreeItem, index: number, templateData: IChatListItemTemplate) {
+	private basicRenderElement(value: ReadonlyArray<Exclude<IChatProgressResponseContent, IChatContentInlineReference>>, element: ChatTreeItem, index: number, templateData: IChatListItemTemplate) {
 		const fillInIncompleteTokens = isResponseVM(element) && (!element.isComplete || element.isCanceled || element.errorDetails?.responseIsFiltered || element.errorDetails?.responseIsIncomplete);
 
 		dom.clearNode(templateData.value);
 		dom.clearNode(templateData.referencesListContainer);
 
 		if (isResponseVM(element)) {
-			this.renderProgressMessage(element, templateData);
+			this.renderDetail(element, templateData);
 		}
 
 		this.renderContentReferencesIfNeeded(element, templateData, templateData.elementDisposables);
 
 		let fileTreeIndex = 0;
 		for (const data of value) {
-			const result = 'value' in data
-				? this.renderMarkdown(data, element, templateData, fillInIncompleteTokens)
-				: this.renderTreeData(data, element, templateData, fileTreeIndex++);
+			const result = data.kind === 'treeData'
+				? this.renderTreeData(data.treeData, element, templateData, fileTreeIndex++)
+				: data.kind === 'markdownContent'
+					? this.renderMarkdown(data.content, element, templateData, fillInIncompleteTokens)
+					: this.renderPlaceholder(new MarkdownString(data.content), templateData);
 			templateData.value.appendChild(result.element);
 			templateData.elementDisposables.add(result);
 		}
@@ -455,17 +488,16 @@ export class ChatListItemRenderer extends Disposable implements ITreeRenderer<Ch
 		const fireEvent = !element.currentRenderedHeight || element.currentRenderedHeight !== newHeight;
 		element.currentRenderedHeight = newHeight;
 		if (fireEvent) {
-			const disposable = templateData.elementDisposables.add(dom.scheduleAtNextAnimationFrame(() => {
+			const disposable = templateData.elementDisposables.add(dom.scheduleAtNextAnimationFrame(dom.getWindow(templateData.value), () => {
 				disposable.dispose();
 				this._onDidChangeItemHeight.fire({ element, height: newHeight });
-			}, dom.getWindow(templateData.value)));
+			}));
 		}
 	}
 
-	private renderWelcomeMessage(element: IChatWelcomeMessageViewModel, templateData: IChatListItemTemplate, height?: number) {
+	private renderWelcomeMessage(element: IChatWelcomeMessageViewModel, templateData: IChatListItemTemplate) {
 		dom.clearNode(templateData.value);
 		dom.clearNode(templateData.referencesListContainer);
-		const slashCommands = this.delegate.getSlashCommands();
 
 		for (const item of element.content) {
 			if (Array.isArray(item)) {
@@ -477,26 +509,19 @@ export class ChatListItemRenderer extends Disposable implements ITreeRenderer<Ch
 					templateData.contextKeyService));
 			} else {
 				const result = this.renderMarkdown(item as IMarkdownString, element, templateData);
-				for (const codeElement of result.element.querySelectorAll('code')) {
-					if (codeElement.textContent && slashCommands.find(command => codeElement.textContent === `/${command.command}`)) {
-						codeElement.classList.add('interactive-slash-command');
-					}
-				}
 				templateData.value.appendChild(result.element);
 				templateData.elementDisposables.add(result);
 			}
 		}
 
-		// When going from welcome content to actual chat list items, rowContainer.offsetHeight is initially 0,
-		// but the height that we get from `renderElement` is accurate, so use that
-		const newHeight = templateData.rowContainer.offsetHeight === 0 && height ? height : templateData.rowContainer.offsetHeight;
+		const newHeight = templateData.rowContainer.offsetHeight;
 		const fireEvent = !element.currentRenderedHeight || element.currentRenderedHeight !== newHeight;
 		element.currentRenderedHeight = newHeight;
 		if (fireEvent) {
-			const disposable = templateData.elementDisposables.add(dom.scheduleAtNextAnimationFrame(() => {
+			const disposable = templateData.elementDisposables.add(dom.scheduleAtNextAnimationFrame(dom.getWindow(templateData.value), () => {
 				disposable.dispose();
 				this._onDidChangeItemHeight.fire({ element, height: newHeight });
-			}, dom.getWindow(templateData.value)));
+			}));
 		}
 	}
 
@@ -528,10 +553,10 @@ export class ChatListItemRenderer extends Disposable implements ITreeRenderer<Ch
 				const renderedPart = renderedParts[index];
 				// Is this part completely new?
 				if (!renderedPart) {
-					if (isInteractiveProgressTreeData(part)) {
-						partsToRender[index] = part;
+					if (part.kind === 'treeData') {
+						partsToRender[index] = part.treeData;
 					} else {
-						const wordCountResult = this.getDataForProgressiveRender(element, part, { renderedWordCount: 0, lastRenderTime: 0 });
+						const wordCountResult = this.getDataForProgressiveRender(element, contentToMarkdown(part.content), { renderedWordCount: 0, lastRenderTime: 0 });
 						if (wordCountResult !== undefined) {
 							partsToRender[index] = {
 								renderedWordCount: wordCountResult.actualWordCount,
@@ -544,13 +569,13 @@ export class ChatListItemRenderer extends Disposable implements ITreeRenderer<Ch
 				}
 
 				// Did this part go from being a placeholder string to resolved tree data?
-				else if (isInteractiveProgressTreeData(part) && !isInteractiveProgressTreeData(renderedPart)) {
-					partsToRender[index] = part;
+				else if (part.kind === 'treeData' && !isInteractiveProgressTreeData(renderedPart)) {
+					partsToRender[index] = part.treeData;
 				}
 
 				// Did this part's content change?
-				else if (!isInteractiveProgressTreeData(part) && !isInteractiveProgressTreeData(renderedPart)) {
-					const wordCountResult = this.getDataForProgressiveRender(element, part, renderedPart);
+				else if (part.kind !== 'treeData' && !isInteractiveProgressTreeData(renderedPart)) {
+					const wordCountResult = this.getDataForProgressiveRender(element, contentToMarkdown(part.content), renderedPart);
 					// Check if there are any new words to render
 					if (wordCountResult !== undefined && renderedPart.renderedWordCount !== wordCountResult?.actualWordCount) {
 						partsToRender[index] = {
@@ -587,8 +612,7 @@ export class ChatListItemRenderer extends Disposable implements ITreeRenderer<Ch
 					// Avoid doing progressive rendering for multiple markdown parts simultaneously
 					else if (!hasRenderedOneMarkdownBlock) {
 						const { value } = wordCountResults[index];
-						const isPlaceholder = isPlaceholderMarkdown(renderableResponse[index]);
-						result = isPlaceholder
+						result = renderableResponse[index].kind === 'asyncContent'
 							? this.renderPlaceholder(new MarkdownString(value), templateData)
 							: this.renderMarkdown(new MarkdownString(value), element, templateData, true);
 						hasRenderedOneMarkdownBlock = true;
@@ -678,9 +702,9 @@ export class ChatListItemRenderer extends Disposable implements ITreeRenderer<Ch
 
 	private renderContentReferencesIfNeeded(element: ChatTreeItem, templateData: IChatListItemTemplate, disposables: DisposableStore): void {
 		dom.clearNode(templateData.referencesListContainer);
-		if (isResponseVM(element) && this._usedReferencesEnabled && element.response.contentReferences.length) {
+		if (isResponseVM(element) && this._usedReferencesEnabled && element.contentReferences.length) {
 			dom.show(templateData.referencesListContainer);
-			const contentReferencesListResult = this.renderContentReferencesListData(element.response.contentReferences, element, templateData);
+			const contentReferencesListResult = this.renderContentReferencesListData(element.contentReferences, element, templateData);
 			templateData.referencesListContainer.appendChild(contentReferencesListResult.element);
 			disposables.add(contentReferencesListResult);
 		} else {
@@ -779,11 +803,7 @@ export class ChatListItemRenderer extends Disposable implements ITreeRenderer<Ch
 		const disposables = new DisposableStore();
 		let codeBlockIndex = 0;
 
-		// TODO if the slash commands stay completely dynamic, this isn't quite right
-		const slashCommands = this.delegate.getSlashCommands();
-		const usedSlashCommand = slashCommands.find(s => markdown.value.startsWith(`/${s.command} `));
-		const toRender = usedSlashCommand ? markdown.value.slice(usedSlashCommand.command.length + 2) : markdown.value;
-		markdown = new MarkdownString(toRender, {
+		markdown = new MarkdownString(markdown.value, {
 			isTrusted: {
 				// Disable all other config options except isTrusted
 				enabledCommands: typeof markdown.isTrusted === 'object' ? markdown.isTrusted?.enabledCommands : [] ?? []
@@ -821,7 +841,8 @@ export class ChatListItemRenderer extends Disposable implements ITreeRenderer<Ch
 				}
 				orderedDisposablesList.push(ref);
 				return ref.object.element;
-			}
+			},
+			asyncRenderCallback: () => this._onDidChangeItemHeight.fire({ element, height: templateData.rowContainer.offsetHeight })
 		});
 
 		if (isResponseVM(element)) {
@@ -831,15 +852,6 @@ export class ChatListItemRenderer extends Disposable implements ITreeRenderer<Ch
 
 		walkTreeAndAnnotateReferenceLinks(result.element);
 
-		if (usedSlashCommand) {
-			const slashCommandElement = $('span.interactive-slash-command', { title: usedSlashCommand.detail }, `/${usedSlashCommand.command} `);
-			if (result.element.firstChild?.nodeName.toLowerCase() === 'p') {
-				result.element.firstChild.insertBefore(slashCommandElement, result.element.firstChild.firstChild);
-			} else {
-				result.element.insertBefore($('p', undefined, slashCommandElement), result.element.firstChild);
-			}
-		}
-
 		orderedDisposablesList.reverse().forEach(d => disposables.add(d));
 		return {
 			element: result.element,
@@ -1299,6 +1311,6 @@ function isInteractiveProgressTreeData(item: IChatResponseProgressFileTreeData |
 	return 'label' in item;
 }
 
-function isPlaceholderMarkdown(item: IPlaceholderMarkdownString | IMarkdownString | IChatResponseProgressFileTreeData): item is IPlaceholderMarkdownString {
-	return 'isPlaceholder' in item;
+function contentToMarkdown(str: string | IMarkdownString): IMarkdownString {
+	return typeof str === 'string' ? { value: str } : str;
 }
diff --git a/src/vs/workbench/contrib/csChat/browser/csChatMarkdownDecorationsRenderer.ts b/src/vs/workbench/contrib/csChat/browser/csChatMarkdownDecorationsRenderer.ts
index 8d078873894..0015e1cf339 100644
--- a/src/vs/workbench/contrib/csChat/browser/csChatMarkdownDecorationsRenderer.ts
+++ b/src/vs/workbench/contrib/csChat/browser/csChatMarkdownDecorationsRenderer.ts
@@ -4,13 +4,14 @@
  *--------------------------------------------------------------------------------------------*/
 
 import * as dom from 'vs/base/browser/dom';
-import { IMarkdownString, MarkdownString, isMarkdownString } from 'vs/base/common/htmlContent';
+import { MarkdownString } from 'vs/base/common/htmlContent';
 import { revive } from 'vs/base/common/marshalling';
 import { basename } from 'vs/base/common/resources';
 import { URI } from 'vs/base/common/uri';
 import { Location } from 'vs/editor/common/languages';
+import { IChatProgressResponseContent } from 'vs/workbench/contrib/chat/common/chatModel';
 import { ChatRequestTextPart, IParsedChatRequest } from 'vs/workbench/contrib/chat/common/chatParserTypes';
-import { IChatContentInlineReference, IChatResponseProgressFileTreeData } from 'vs/workbench/contrib/chat/common/chatService';
+import { IChatContentInlineReference } from 'vs/workbench/contrib/chat/common/chatService';
 
 const variableRefUrl = 'http://_vscodedecoration_';
 
@@ -59,21 +60,21 @@ function renderFileWidget(href: string, a: HTMLAnchorElement): void {
 
 const contentRefUrl = 'http://_vscodecontentref_'; // must be lowercase for URI
 
-export function reduceInlineContentReferences(response: ReadonlyArray<IMarkdownString | IChatResponseProgressFileTreeData | IChatContentInlineReference>): ReadonlyArray<IMarkdownString | IChatResponseProgressFileTreeData> {
-	const result: (IMarkdownString | IChatResponseProgressFileTreeData)[] = [];
+export function reduceInlineContentReferences(response: ReadonlyArray<IChatProgressResponseContent>): ReadonlyArray<Exclude<IChatProgressResponseContent, IChatContentInlineReference>> {
+	const result: Exclude<IChatProgressResponseContent, IChatContentInlineReference>[] = [];
 	for (const item of response) {
 		const previousItem = result[result.length - 1];
-		if ('inlineReference' in item) {
+		if (item.kind === 'inlineReference') {
 			const location = 'uri' in item.inlineReference ? item.inlineReference : { uri: item.inlineReference };
 			const printUri = URI.parse(contentRefUrl).with({ fragment: JSON.stringify(location) });
 			const markdownText = `[${item.name || basename(location.uri)}](${printUri.toString()})`;
-			if (isMarkdownString(previousItem)) {
-				result[result.length - 1] = new MarkdownString(previousItem.value + markdownText, { isTrusted: previousItem.isTrusted });
+			if (previousItem?.kind === 'markdownContent') {
+				result[result.length - 1] = { content: new MarkdownString(previousItem.content.value + markdownText, { isTrusted: previousItem.content.isTrusted }), kind: 'markdownContent' };
 			} else {
-				result.push(new MarkdownString(markdownText));
+				result.push({ content: new MarkdownString(markdownText), kind: 'markdownContent' });
 			}
-		} else if (isMarkdownString(item) && isMarkdownString(previousItem)) {
-			result[result.length - 1] = new MarkdownString(previousItem.value + item.value, { isTrusted: previousItem.isTrusted });
+		} else if (item.kind === 'markdownContent' && previousItem?.kind === 'markdownContent') {
+			result[result.length - 1] = { content: new MarkdownString(previousItem.content.value + item.content.value, { isTrusted: previousItem.content.isTrusted }), kind: 'markdownContent' };
 		} else {
 			result.push(item);
 		}
diff --git a/src/vs/workbench/contrib/csChat/browser/csChatViewPane.ts b/src/vs/workbench/contrib/csChat/browser/csChatViewPane.ts
index 94f1b00cf36..8ea8b39634d 100644
--- a/src/vs/workbench/contrib/csChat/browser/csChatViewPane.ts
+++ b/src/vs/workbench/contrib/csChat/browser/csChatViewPane.ts
@@ -71,12 +71,22 @@ export class ChatViewPane extends ViewPane implements IChatViewPane {
 			if (providerId === this.chatViewOptions.providerId && !this._widget?.viewModel) {
 				const sessionId = this.getSessionId();
 				const model = sessionId ? this.chatService.getOrRestoreSession(sessionId) : undefined;
-				this.updateModel(model);
+
+				// The widget may be hidden at this point, because welcome views were allowed. Use setVisible to
+				// avoid doing a render while the widget is hidden. This is changing the condition in `shouldShowWelcome`
+				// so it should fire onDidChangeViewWelcomeState.
+				try {
+					this._widget.setVisible(false);
+					this.updateModel(model);
+					this._onDidChangeViewWelcomeState.fire();
+				} finally {
+					this.widget.setVisible(true);
+				}
 			}
 		}));
 	}
 
-	private updateModel(model?: IChatModel | undefined): void {
+	private updateModel(model?: IChatModel | undefined, viewState?: IViewPaneState): void {
 		this.modelDisposables.clear();
 
 		model = model ?? (this.chatService.transferredSessionData?.sessionId
@@ -86,7 +96,7 @@ export class ChatViewPane extends ViewPane implements IChatViewPane {
 			throw new Error('Could not start chat session');
 		}
 
-		this._widget.setModel(model, { ...this.viewState });
+		this._widget.setModel(model, { ...(viewState ?? this.viewState) });
 		this.viewState.sessionId = model.sessionId;
 	}
 
@@ -155,8 +165,7 @@ export class ChatViewPane extends ViewPane implements IChatViewPane {
 		if (this.widget.viewModel) {
 			this.chatService.clearSession(this.widget.viewModel.sessionId);
 		}
-		this.viewState.inputValue = '';
-		this.updateModel();
+		this.updateModel(undefined, { ...this.viewState, inputValue: undefined });
 	}
 
 	loadSession(sessionId: string): void {
diff --git a/src/vs/workbench/contrib/csChat/browser/csChatWidget.ts b/src/vs/workbench/contrib/csChat/browser/csChatWidget.ts
index c6f79e430df..0bf13a5db1a 100644
--- a/src/vs/workbench/contrib/csChat/browser/csChatWidget.ts
+++ b/src/vs/workbench/contrib/csChat/browser/csChatWidget.ts
@@ -6,7 +6,6 @@
 import * as dom from 'vs/base/browser/dom';
 import { ITreeContextMenuEvent, ITreeElement } from 'vs/base/browser/ui/tree/tree';
 import { disposableTimeout } from 'vs/base/common/async';
-import { CancellationToken } from 'vs/base/common/cancellation';
 import { toErrorMessage } from 'vs/base/common/errorMessage';
 import { Emitter } from 'vs/base/common/event';
 import { Disposable, DisposableStore, IDisposable, MutableDisposable, combinedDisposable, toDisposable } from 'vs/base/common/lifecycle';
@@ -23,15 +22,15 @@ import { ServiceCollection } from 'vs/platform/instantiation/common/serviceColle
 import { WorkbenchObjectTree } from 'vs/platform/list/browser/listService';
 import { ILogService } from 'vs/platform/log/common/log';
 import { IViewsService } from 'vs/workbench/common/views';
-import { ChatTreeItem, IChatWidgetViewOptions, IChatAccessibilityService, IChatCodeBlockInfo, IChatFileTreeInfo, IChatWidget, IChatWidgetService, IChatWidgetViewContext } from 'vs/workbench/contrib/chat/browser/chat';
+import { ChatTreeItem, IChatAccessibilityService, IChatCodeBlockInfo, IChatFileTreeInfo, IChatWidget, IChatWidgetService, IChatWidgetViewContext, IChatWidgetViewOptions } from 'vs/workbench/contrib/chat/browser/chat';
 import { ChatInputPart } from 'vs/workbench/contrib/chat/browser/chatInputPart';
 import { ChatAccessibilityProvider, ChatListDelegate, ChatListItemRenderer, IChatListItemRendererOptions, IChatRendererDelegate } from 'vs/workbench/contrib/chat/browser/chatListRenderer';
 import { ChatEditorOptions } from 'vs/workbench/contrib/chat/browser/chatOptions';
 import { ChatViewPane } from 'vs/workbench/contrib/chat/browser/chatViewPane';
-import { CONTEXT_CHAT_REQUEST_IN_PROGRESS, CONTEXT_IN_CHAT_SESSION } from 'vs/workbench/contrib/chat/common/chatContextKeys';
+import { CONTEXT_CHAT_REQUEST_IN_PROGRESS, CONTEXT_IN_CHAT_SESSION, CONTEXT_RESPONSE_FILTERED } from 'vs/workbench/contrib/chat/common/chatContextKeys';
 import { IChatContributionService } from 'vs/workbench/contrib/chat/common/chatContributionService';
 import { ChatModelInitState, IChatModel } from 'vs/workbench/contrib/chat/common/chatModel';
-import { IChatReplyFollowup, IChatService, ISlashCommand } from 'vs/workbench/contrib/chat/common/chatService';
+import { IChatReplyFollowup, IChatService } from 'vs/workbench/contrib/chat/common/chatService';
 import { ChatViewModel, IChatResponseViewModel, isRequestVM, isResponseVM, isWelcomeVM } from 'vs/workbench/contrib/chat/common/chatViewModel';
 
 const $ = dom.$;
@@ -109,15 +108,6 @@ export class ChatWidget extends Disposable implements IChatWidget {
 			this.viewModelDisposables.add(viewModel);
 		}
 
-		this.slashCommandsPromise = undefined;
-		this.lastSlashCommands = undefined;
-
-		this.getSlashCommands().then(() => {
-			if (!this._isDisposed) {
-				this.onDidChangeItems();
-			}
-		});
-
 		this._onDidChangeViewModel.fire();
 	}
 
@@ -125,9 +115,6 @@ export class ChatWidget extends Disposable implements IChatWidget {
 		return this._viewModel;
 	}
 
-	private lastSlashCommands: ISlashCommand[] | undefined;
-	private slashCommandsPromise: Promise<ISlashCommand[] | undefined> | undefined;
-
 	constructor(
 		readonly viewContext: IChatWidgetViewContext,
 		private readonly viewOptions: IChatWidgetViewOptions,
@@ -164,12 +151,6 @@ export class ChatWidget extends Disposable implements IChatWidget {
 		return this.inputPart.inputUri;
 	}
 
-	private _isDisposed: boolean = false;
-	public override dispose(): void {
-		this._isDisposed = true;
-		super.dispose();
-	}
-
 	render(parent: HTMLElement): void {
 		const viewId = 'viewId' in this.viewContext ? this.viewContext.viewId : undefined;
 		this.editorOptions = this._register(this.instantiationService.createInstance(ChatEditorOptions, viewId, this.styles.listForeground, this.styles.inputEditorBackground, this.styles.resultEditorBackground));
@@ -260,12 +241,12 @@ export class ChatWidget extends Disposable implements IChatWidget {
 							// TODO? We can give the welcome message a proper VM or get rid of the rest of the VMs
 							((isWelcomeVM(element) && this.viewModel) ? `_${ChatModelInitState[this.viewModel.initState]}` : '') +
 							// Ensure re-rendering an element once slash commands are loaded, so the colorization can be applied.
-							`${(isRequestVM(element) || isWelcomeVM(element)) && !!this.lastSlashCommands ? '_scLoaded' : ''}` +
+							`${(isRequestVM(element) || isWelcomeVM(element)) /* && !!this.lastSlashCommands ? '_scLoaded' : '' */}` +
 							// If a response is in the process of progressive rendering, we need to ensure that it will
 							// be re-rendered so progressive rendering is restarted, even if the model wasn't updated.
 							`${isResponseVM(element) && element.renderData ? `_${this.visibleChangeCount}` : ''}` +
 							// Re-render once content references are loaded
-							(isResponseVM(element) ? `_${element.response.contentReferences.length}` : '');
+							(isResponseVM(element) ? `_${element.contentReferences.length}` : '');
 					},
 				}
 			});
@@ -309,27 +290,11 @@ export class ChatWidget extends Disposable implements IChatWidget {
 		}
 	}
 
-	async getSlashCommands(): Promise<ISlashCommand[] | undefined> {
-		if (!this.viewModel) {
-			return;
-		}
-
-		if (!this.slashCommandsPromise) {
-			this.slashCommandsPromise = this.chatService.getSlashCommands(this.viewModel.sessionId, CancellationToken.None).then(commands => {
-				this.lastSlashCommands = commands ?? [];
-				return this.lastSlashCommands;
-			});
-		}
-
-		return this.slashCommandsPromise;
-	}
-
 	private createList(listContainer: HTMLElement, options: IChatListItemRendererOptions): void {
 		const scopedInstantiationService = this.instantiationService.createChild(new ServiceCollection([IContextKeyService, this.contextKeyService]));
 		const delegate = scopedInstantiationService.createInstance(ChatListDelegate);
 		const rendererDelegate: IChatRendererDelegate = {
 			getListLength: () => this.tree.getNode(null).visibleChildrenCount,
-			getSlashCommands: () => this.lastSlashCommands ?? [],
 		};
 		this.renderer = this._register(scopedInstantiationService.createInstance(
 			ChatListItemRenderer,
@@ -389,12 +354,16 @@ export class ChatWidget extends Disposable implements IChatWidget {
 		e.browserEvent.preventDefault();
 		e.browserEvent.stopPropagation();
 
+		const selected = e.element;
+		const scopedContextKeyService = this.contextKeyService.createOverlay([
+			[CONTEXT_RESPONSE_FILTERED.key, isResponseVM(selected) && !!selected.errorDetails?.responseIsFiltered]
+		]);
 		this.contextMenuService.showContextMenu({
 			menuId: MenuId.ChatContext,
 			menuActionOptions: { shouldForwardArgs: true },
-			contextKeyService: this.contextKeyService,
+			contextKeyService: scopedContextKeyService,
 			getAnchor: () => e.anchor,
-			getActionsContext: () => e.element,
+			getActionsContext: () => selected,
 		});
 	}
 
@@ -404,10 +373,10 @@ export class ChatWidget extends Disposable implements IChatWidget {
 			// Consider the tree to be scrolled all the way down if it is within 2px of the bottom.
 			const lastElementWasVisible = this.tree.scrollTop + this.tree.renderHeight >= this.previousTreeScrollHeight - 2;
 			if (lastElementWasVisible) {
-				dom.scheduleAtNextAnimationFrame(() => {
+				dom.scheduleAtNextAnimationFrame(dom.getWindow(this.listContainer), () => {
 					// Can't set scrollTop during this event listener, the list might overwrite the change
 					revealLastElement(this.tree);
-				}, dom.getWindow(this.listContainer), 0);
+				}, 0);
 			}
 		}
 
@@ -462,7 +431,6 @@ export class ChatWidget extends Disposable implements IChatWidget {
 		this.container.setAttribute('data-session-id', model.sessionId);
 		this.viewModel = this.instantiationService.createInstance(ChatViewModel, model);
 		this.viewModelDisposables.add(this.viewModel.onDidChange(e => {
-			this.slashCommandsPromise = undefined;
 			this.requestInProgress.set(this.viewModel!.requestInProgress);
 			this.onDidChangeItems();
 			if (e?.kind === 'addRequest') {
@@ -475,7 +443,7 @@ export class ChatWidget extends Disposable implements IChatWidget {
 			this.viewModel = undefined;
 			this.onDidChangeItems();
 		}));
-		this.inputPart.setState(model.providerId, viewState.inputValue ?? '');
+		this.inputPart.setState(model.providerId, viewState.inputValue);
 
 		if (this.tree) {
 			this.onDidChangeItems();
@@ -536,8 +504,7 @@ export class ChatWidget extends Disposable implements IChatWidget {
 				'query' in opts ? opts.query :
 					`${opts.prefix} ${editorValue}`;
 			const isUserQuery = !opts || 'query' in opts;
-			const usedSlashCommand = this.lookupSlashCommand(input);
-			const result = await this.chatService.sendRequest(this.viewModel.sessionId, input, usedSlashCommand);
+			const result = await this.chatService.sendRequest(this.viewModel.sessionId, input);
 
 			if (result) {
 				this.inputPart.acceptInput(isUserQuery ? input : undefined);
@@ -552,10 +519,6 @@ export class ChatWidget extends Disposable implements IChatWidget {
 		}
 	}
 
-	private lookupSlashCommand(input: string): ISlashCommand | undefined {
-		return this.lastSlashCommands?.find(sc => input.startsWith(`/${sc.command}`));
-	}
-
 	getCodeBlockInfosForResponse(response: IChatResponseViewModel): IChatCodeBlockInfo[] {
 		return this.renderer.getCodeBlockInfosForResponse(response);
 	}
@@ -625,7 +588,7 @@ export class ChatWidget extends Disposable implements IChatWidget {
 			if (!this._dynamicMessageLayoutData?.enabled) {
 				return;
 			}
-			mutableDisposable.value = dom.scheduleAtNextAnimationFrame(() => {
+			mutableDisposable.value = dom.scheduleAtNextAnimationFrame(dom.getWindow(this.listContainer), () => {
 				if (!e.scrollTopChanged || e.heightChanged || e.scrollHeightChanged) {
 					return;
 				}
@@ -640,7 +603,7 @@ export class ChatWidget extends Disposable implements IChatWidget {
 				const inputPartHeight = this.inputPart.layout(possibleMaxHeight, width);
 				const newHeight = Math.min(renderHeight + diff, possibleMaxHeight - inputPartHeight);
 				this.layout(newHeight + inputPartHeight, width);
-			}, dom.getWindow(this.listContainer));
+			});
 		}));
 	}
 
diff --git a/src/vs/workbench/contrib/csChat/browser/media/csChat.css b/src/vs/workbench/contrib/csChat/browser/media/csChat.css
index 057ad815146..bbda4c71f5d 100644
--- a/src/vs/workbench/contrib/csChat/browser/media/csChat.css
+++ b/src/vs/workbench/contrib/csChat/browser/media/csChat.css
@@ -31,6 +31,10 @@
 	justify-content: space-between;
 }
 
+.interactive-item-container .header.hidden {
+	display: none;
+}
+
 .interactive-item-container .header .user {
 	display: flex;
 	align-items: center;
@@ -48,6 +52,11 @@
 	opacity: 0.7;
 }
 
+.interactive-item-container .chat-animated-ellipsis {
+	display: inline-block;
+	width: 11px;
+}
+
 .interactive-item-container:not(.show-progress) .chat-animated-ellipsis {
 	display: none;
 }
@@ -70,7 +79,7 @@
 	}
 }
 
-.chat-animated-ellipsis::after {
+.interactive-item-container .chat-animated-ellipsis::after {
 	content: '';
 	white-space: nowrap;
 	overflow: hidden;
@@ -185,6 +194,18 @@
 	color: var(--vscode-textLink-activeForeground);
 }
 
+.hc-black .interactive-item-container .value .rendered-markdown a code,
+.hc-light .interactive-item-container .value .rendered-markdown a code {
+	color: var(--vscode-textPreformat-foreground);
+}
+
+.hc-black .interactive-item-container .value .rendered-markdown a:hover,
+.hc-black .interactive-item-container .value .rendered-markdown a:active,
+.hc-light .interactive-item-container .value .rendered-markdown a:hover,
+.hc-light .interactive-item-container .value .rendered-markdown a:active {
+	color: var(--vscode-textPreformat-foreground);
+}
+
 .interactive-list {
 	overflow: hidden;
 }
@@ -253,13 +274,17 @@
 	padding: 8px 20px;
 }
 
+.interactive-item-container.interactive-item-compact.no-padding {
+	padding: unset;
+}
+
 .interactive-item-container.interactive-item-compact .header {
 	height: 16px;
 }
 
 .interactive-item-container.interactive-item-compact .header .avatar {
-	width: 16px;
-	height: 16px;
+	width: 18px;
+	height: 18px;
 }
 
 .interactive-item-container.interactive-item-compact .header .avatar .icon {
@@ -267,7 +292,7 @@
 	height: 16px;
 }
 
-.interactive-item-container.interactive-item-compact .header .avatar+.avatar .codicon {
+.interactive-item-container.interactive-item-compact .header .codicon-avatar .codicon {
 	font-size: 12px;
 }
 
@@ -378,10 +403,6 @@
 	color: var(--vscode-notificationsInfoIcon-foreground) !important; /* Have to override default styles which apply to all lists */
 }
 
-.interactive-item-container .value .interactive-slash-command {
-	color: var(--vscode-textLink-foreground);
-}
-
 .interactive-session .interactive-input-part {
 	padding: 12px 0px;
 	display: flex;
@@ -447,8 +468,9 @@
 }
 
 .interactive-item-container.filtered-response .value > .rendered-markdown {
-	-webkit-mask-image: linear-gradient(rgba(0, 0, 0, 0.85), rgba(0, 0, 0, 0.05));
-	mask-image: linear-gradient(rgba(0, 0, 0, 0.85), rgba(0, 0, 0, 0.05));
+	pointer-events: none;
+	-webkit-mask-image: linear-gradient(rgba(0, 0, 0, 0.75), rgba(0, 0, 0, 0.05) 60%, rgba(0, 0, 0, 0.00) 80%);
+	mask-image: linear-gradient(rgba(0, 0, 0, 0.75), rgba(0, 0, 0, 0.05) 60%, rgba(0, 0, 0, 0.00) 80%);
 }
 
 /* #region Quick Chat */
@@ -472,6 +494,10 @@
 	border-bottom-left-radius: 6px;
 }
 
+.quick-input-widget .interactive-response {
+	min-height: 86px;
+}
+
 /* #endregion */
 
 .interactive-response-progress-tree .monaco-list-row:not(.selected) .monaco-tl-row:hover {
@@ -501,7 +527,6 @@
 	gap: 6px;
 }
 
-.interactive-response-progress-tree .monaco-list,
 .chat-used-context-list .monaco-list {
 	border: none;
 	border-radius: 4px;
@@ -526,11 +551,12 @@
 	gap: 6px;
 }
 
+.interactive-response-progress-tree,
 .interactive-session .chat-used-context-list {
 	border: 1px solid var(--vscode-chat-requestBorder);
 	border-radius: 4px;
-	padding: 4px;
 	margin-bottom: 8px;
+	padding: 4px;
 }
 
 .interactive-session .chat-used-context-list .monaco-list .monaco-list-row {
@@ -569,3 +595,21 @@
 .interactive-session .chat-used-context .chat-used-context-label .monaco-button .codicon {
 	margin: 0 0 0 4px;
 }
+
+.interactive-item-container .progress-steps {
+	display: flex;
+	flex-direction: column;
+	gap: 4px;
+	margin-left: 4px;
+}
+
+.interactive-item-container .progress-steps .progress-step {
+	display: flex;
+	gap: 5px;
+	align-items: center;
+	opacity: 0.7;
+}
+
+.interactive-item-container .progress-steps .progress-step .codicon-check {
+	color: var(--vscode-debugIcon-startForeground);
+}
diff --git a/src/vs/workbench/contrib/csChat/common/csChatAgents.ts b/src/vs/workbench/contrib/csChat/common/csChatAgents.ts
index 1845706b098..157e4be57a2 100644
--- a/src/vs/workbench/contrib/csChat/common/csChatAgents.ts
+++ b/src/vs/workbench/contrib/csChat/common/csChatAgents.ts
@@ -5,13 +5,14 @@
 
 import { CancellationToken } from 'vs/base/common/cancellation';
 import { Emitter, Event } from 'vs/base/common/event';
+import { IMarkdownString } from 'vs/base/common/htmlContent';
 import { Iterable } from 'vs/base/common/iterator';
 import { Disposable, IDisposable, toDisposable } from 'vs/base/common/lifecycle';
 import { ThemeIcon } from 'vs/base/common/themables';
 import { URI } from 'vs/base/common/uri';
 import { createDecorator } from 'vs/platform/instantiation/common/instantiation';
 import { IChatMessage } from 'vs/workbench/contrib/chat/common/chatProvider';
-import { IChatFollowup, IChatProgress, IChatResponseErrorDetails, IChatResponseProgressFileTreeData } from 'vs/workbench/contrib/chat/common/chatService';
+import { IChatFollowup, IChatProgress, IChatResponseErrorDetails } from 'vs/workbench/contrib/chat/common/chatService';
 import { IChatRequestVariableValue } from 'vs/workbench/contrib/chat/common/chatVariables';
 
 //#region agent service, commands etc
@@ -27,40 +28,45 @@ export interface IChatAgent extends IChatAgentData {
 	provideSlashCommands(token: CancellationToken): Promise<IChatAgentCommand[]>;
 }
 
-export interface IChatAgentFragment {
-	content: string | { treeData: IChatResponseProgressFileTreeData };
-}
-
 export interface IChatAgentCommand {
 	name: string;
 	description: string;
+
 	/**
 	 * Whether the command should execute as soon
 	 * as it is entered. Defaults to `false`.
 	 */
 	executeImmediately?: boolean;
+
 	/**
 	 * Whether executing the command puts the
 	 * chat into a persistent mode, where the
 	 * slash command is prepended to the chat input.
 	 */
 	shouldRepopulate?: boolean;
+
 	/**
 	 * Placeholder text to render in the chat input
 	 * when the slash command has been repopulated.
 	 * Has no effect if `shouldRepopulate` is `false`.
 	 */
 	followupPlaceholder?: string;
+
+	sampleRequest?: string;
 }
 
 export interface IChatAgentMetadata {
 	description?: string;
 	isDefault?: boolean; // The agent invoked when no agent is specified
+	helpTextPrefix?: string | IMarkdownString;
+	helpTextPostfix?: string | IMarkdownString;
 	isSecondary?: boolean; // Invoked by ctrl/cmd+enter
 	fullName?: string;
 	icon?: URI;
 	iconDark?: URI;
 	themeIcon?: ThemeIcon;
+	sampleRequest?: string;
+	supportIssueReporting?: boolean;
 }
 
 export interface IChatAgentRequest {
diff --git a/src/vs/workbench/contrib/csChat/common/csChatContextKeys.ts b/src/vs/workbench/contrib/csChat/common/csChatContextKeys.ts
index 631f0af7d00..85941ee0fd4 100644
--- a/src/vs/workbench/contrib/csChat/common/csChatContextKeys.ts
+++ b/src/vs/workbench/contrib/csChat/common/csChatContextKeys.ts
@@ -6,8 +6,8 @@
 import { localize } from 'vs/nls';
 import { RawContextKey } from 'vs/platform/contextkey/common/contextkey';
 
-export const CONTEXT_RESPONSE_HAS_PROVIDER_ID = new RawContextKey<boolean>('chatSessionResponseHasProviderId', false, { type: 'boolean', description: localize('interactiveSessionResponseHasProviderId', "True when the provider has assigned an id to this response.") });
 export const CONTEXT_RESPONSE_VOTE = new RawContextKey<string>('chatSessionResponseVote', '', { type: 'string', description: localize('interactiveSessionResponseVote', "When the response has been voted up, is set to 'up'. When voted down, is set to 'down'. Otherwise an empty string.") });
+export const CONTEXT_CHAT_RESPONSE_SUPPORT_ISSUE_REPORTING = new RawContextKey<boolean>('chatResponseSupportsIssueReporting', false, { type: 'boolean', description: localize('chatResponseSupportsIssueReporting', "True when the current chat response supports issue reporting.") });
 export const CONTEXT_RESPONSE_FILTERED = new RawContextKey<boolean>('chatSessionResponseFiltered', false, { type: 'boolean', description: localize('chatResponseFiltered', "True when the chat response was filtered out by the server.") });
 export const CONTEXT_CHAT_REQUEST_IN_PROGRESS = new RawContextKey<boolean>('chatSessionRequestInProgress', false, { type: 'boolean', description: localize('interactiveSessionRequestInProgress', "True when the current request is still in progress.") });
 
diff --git a/src/vs/workbench/contrib/csChat/common/csChatModel.ts b/src/vs/workbench/contrib/csChat/common/csChatModel.ts
index 471764b058f..d4617660efe 100644
--- a/src/vs/workbench/contrib/csChat/common/csChatModel.ts
+++ b/src/vs/workbench/contrib/csChat/common/csChatModel.ts
@@ -3,7 +3,7 @@
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
 
-import { firstOrDefault } from 'vs/base/common/arrays';
+import { asArray, firstOrDefault } from 'vs/base/common/arrays';
 import { DeferredPromise } from 'vs/base/common/async';
 import { Emitter, Event } from 'vs/base/common/event';
 import { IMarkdownString, MarkdownString, isMarkdownString } from 'vs/base/common/htmlContent';
@@ -16,11 +16,10 @@ import { OffsetRange } from 'vs/editor/common/core/offsetRange';
 import { ILogService } from 'vs/platform/log/common/log';
 import { IChatAgentCommand, IChatAgentData, IChatAgentService } from 'vs/workbench/contrib/chat/common/chatAgents';
 import { ChatRequestTextPart, IParsedChatRequest, reviveParsedChatRequest } from 'vs/workbench/contrib/chat/common/chatParserTypes';
-import { IChat, IChatContentInlineReference, IChatContentReference, IChatFollowup, IChatProgress, IChatReplyFollowup, IChatResponse, IChatResponseErrorDetails, IChatResponseProgressFileTreeData, IUsedContext, InteractiveSessionVoteDirection, isIUsedContext } from 'vs/workbench/contrib/chat/common/chatService';
+import { IChat, IChatAsyncContent, IChatContent, IChatContentInlineReference, IChatContentReference, IChatFollowup, IChatMarkdownContent, IChatProgress, IChatProgressMessage, IChatReplyFollowup, IChatResponse, IChatResponseErrorDetails, IChatResponseProgressFileTreeData, IChatTreeData, IChatUsedContext, InteractiveSessionVoteDirection, isIUsedContext } from 'vs/workbench/contrib/chat/common/chatService';
 
 export interface IChatRequestModel {
 	readonly id: string;
-	readonly providerRequestId: string | undefined;
 	readonly username: string;
 	readonly avatarIconUri?: URI;
 	readonly session: IChatModel;
@@ -28,24 +27,14 @@ export interface IChatRequestModel {
 	readonly response: IChatResponseModel | undefined;
 }
 
-export type ResponsePart =
-	| string
-	| IMarkdownString
-	| { treeData: IChatResponseProgressFileTreeData }
-	| {
-		placeholder: string;
-		resolvedContent?: Promise<
-			string | IMarkdownString | { treeData: IChatResponseProgressFileTreeData }
-		>;
-	}
-	| IUsedContext
-	| IChatContentReference
+export type IChatProgressResponseContent =
+	| IChatMarkdownContent
+	| IChatTreeData
+	| IChatAsyncContent
 	| IChatContentInlineReference;
 
 export interface IResponse {
-	readonly value: ReadonlyArray<IMarkdownString | IPlaceholderMarkdownString | IChatResponseProgressFileTreeData | IChatContentInlineReference>;
-	readonly usedContext: IUsedContext | undefined;
-	readonly contentReferences: ReadonlyArray<IChatContentReference>;
+	readonly value: ReadonlyArray<IChatProgressResponseContent>;
 	asString(): string;
 }
 
@@ -53,12 +42,14 @@ export interface IChatResponseModel {
 	readonly onDidChange: Event<void>;
 	readonly id: string;
 	readonly providerId: string;
-	readonly providerResponseId: string | undefined;
 	readonly requestId: string;
 	readonly username: string;
 	readonly avatarIconUri?: URI;
 	readonly session: IChatModel;
 	readonly agent?: IChatAgentData;
+	readonly usedContext: IChatUsedContext | undefined;
+	readonly contentReferences: ReadonlyArray<IChatContentReference>;
+	readonly progressMessages: ReadonlyArray<IChatProgressMessage>;
 	readonly slashCommand?: IChatAgentCommand;
 	readonly response: IResponse;
 	readonly isComplete: boolean;
@@ -79,10 +70,6 @@ export class ChatRequestModel implements IChatRequestModel {
 		return this._id;
 	}
 
-	public get providerRequestId(): string | undefined {
-		return this._providerRequestId;
-	}
-
 	public get username(): string {
 		return this.session.requesterUsername;
 	}
@@ -93,146 +80,98 @@ export class ChatRequestModel implements IChatRequestModel {
 
 	constructor(
 		public readonly session: ChatModel,
-		public readonly message: IParsedChatRequest,
-		private _providerRequestId?: string) {
+		public readonly message: IParsedChatRequest) {
 		this._id = 'request_' + ChatRequestModel.nextId++;
 	}
-
-	setProviderRequestId(providerRequestId: string) {
-		this._providerRequestId = providerRequestId;
-	}
 }
 
-export interface IPlaceholderMarkdownString extends IMarkdownString {
-	isPlaceholder: boolean;
-}
-
-type InternalResponsePart =
-	| { string: IMarkdownString; isPlaceholder?: boolean }
-	| IChatContentInlineReference
-	| { treeData: IChatResponseProgressFileTreeData; isPlaceholder?: undefined };
-
 export class Response implements IResponse {
 	private _onDidChangeValue = new Emitter<void>();
 	public get onDidChangeValue() {
 		return this._onDidChangeValue.event;
 	}
 
-	private _contentReferences: IChatContentReference[] = [];
-	public get contentReferences(): IChatContentReference[] {
-		return this._contentReferences;
-	}
-
-	private _usedContext: IUsedContext | undefined;
-	public get usedContext(): IUsedContext | undefined {
-		return this._usedContext;
-	}
-
 	// responseParts internally tracks all the response parts, including strings which are currently resolving, so that they can be updated when they do resolve
-	private _responseParts: InternalResponsePart[];
-	// responseData externally presents the response parts with consolidated contiguous strings (including strings which were previously resolving)
-	private _responseData: (IMarkdownString | IPlaceholderMarkdownString | IChatResponseProgressFileTreeData | IChatContentInlineReference)[];
+	private _responseParts: IChatProgressResponseContent[];
 	// responseRepr externally presents the response parts with consolidated contiguous strings (excluding tree data)
-	private _responseRepr: string;
+	private _responseRepr!: string;
 
-	get value(): (IMarkdownString | IPlaceholderMarkdownString | IChatResponseProgressFileTreeData | IChatContentInlineReference)[] {
-		return this._responseData;
+	get value(): IChatProgressResponseContent[] {
+		return this._responseParts;
 	}
 
 	constructor(value: IMarkdownString | ReadonlyArray<IMarkdownString | IChatResponseProgressFileTreeData | IChatContentInlineReference>) {
-		this._responseData = Array.isArray(value) ? value : [value];
-		this._responseParts = Array.isArray(value) ? value.map((v) => ('value' in v ? { string: v } : { treeData: v })) : [{ string: value }];
-		this._responseRepr = this._responseParts.map((part) => {
-			if (isCompleteInteractiveProgressTreeData(part)) {
-				return '';
-			}
-			// TODO duplicates _updateRepr
-			if ('inlineReference' in part) {
-				return basename('uri' in part.inlineReference ? part.inlineReference.uri : part.inlineReference);
-			}
-			return part.string.value;
-		}).join('\n');
+		this._responseParts = asArray(value).map((v) => (isMarkdownString(v) ?
+			{ content: v, kind: 'markdownContent' } satisfies IChatMarkdownContent :
+			'kind' in v ? v : { kind: 'treeData', treeData: v }));
+
+		this._updateRepr(true);
 	}
 
 	asString(): string {
 		return this._responseRepr;
 	}
 
-	updateContent(responsePart: ResponsePart, quiet?: boolean): void {
-		if (typeof responsePart === 'string' || isMarkdownString(responsePart)) {
+	updateContent(progress: IChatProgressResponseContent | IChatContent, quiet?: boolean): void {
+		if (progress.kind === 'content' || progress.kind === 'markdownContent') {
 			const responsePartLength = this._responseParts.length - 1;
 			const lastResponsePart = this._responseParts[responsePartLength];
 
-			if (lastResponsePart && ('inlineReference' in lastResponsePart || lastResponsePart.isPlaceholder === true || isCompleteInteractiveProgressTreeData(lastResponsePart))) {
-				// The last part is resolving or a tree data item, start a new part
-				this._responseParts.push({ string: typeof responsePart === 'string' ? new MarkdownString(responsePart) : responsePart });
-			} else if (lastResponsePart) {
-				// Combine this part with the last, non-resolving string part
-				if (isMarkdownString(responsePart)) {
-					this._responseParts[responsePartLength] = { string: new MarkdownString(lastResponsePart.string.value + responsePart.value, responsePart) };
+			if (!lastResponsePart || lastResponsePart.kind !== 'markdownContent') {
+				// The last part can't be merged with
+				if (progress.kind === 'content') {
+					this._responseParts.push({ content: new MarkdownString(progress.content), kind: 'markdownContent' });
 				} else {
-					this._responseParts[responsePartLength] = { string: new MarkdownString(lastResponsePart.string.value + responsePart, lastResponsePart.string) };
+					this._responseParts.push(progress);
 				}
+			} else if (progress.kind === 'markdownContent') {
+				// Merge all enabled commands
+				const lastPartEnabledCommands = typeof lastResponsePart.content.isTrusted === 'object' ?
+					lastResponsePart.content.isTrusted.enabledCommands :
+					[];
+				const thisPartEnabledCommands = typeof progress.content.isTrusted === 'object' ?
+					progress.content.isTrusted.enabledCommands :
+					[];
+				const enabledCommands = [...lastPartEnabledCommands, ...thisPartEnabledCommands];
+				this._responseParts[responsePartLength] = { content: new MarkdownString(lastResponsePart.content.value + progress.content.value, { isTrusted: { enabledCommands } }), kind: 'markdownContent' };
 			} else {
-				this._responseParts.push({ string: isMarkdownString(responsePart) ? responsePart : new MarkdownString(responsePart) });
+				this._responseParts[responsePartLength] = { content: new MarkdownString(lastResponsePart.content.value + progress.content, lastResponsePart.content), kind: 'markdownContent' };
 			}
 
 			this._updateRepr(quiet);
-		} else if ('placeholder' in responsePart) {
+		} else if (progress.kind === 'asyncContent') {
 			// Add a new resolving part
-			const responsePosition = this._responseParts.push({ string: new MarkdownString(responsePart.placeholder), isPlaceholder: true }) - 1;
+			const responsePosition = this._responseParts.push(progress) - 1;
 			this._updateRepr(quiet);
 
-			responsePart.resolvedContent?.then((content) => {
+			progress.resolvedContent?.then((content) => {
 				// Replace the resolving part's content with the resolved response
 				if (typeof content === 'string') {
-					this._responseParts[responsePosition] = { string: new MarkdownString(content), isPlaceholder: true };
-					this._updateRepr(quiet);
-				} else if ('value' in content) {
-					this._responseParts[responsePosition] = { string: content, isPlaceholder: true };
-					this._updateRepr(quiet);
-				} else if (content.treeData) {
-					this._responseParts[responsePosition] = { treeData: content.treeData };
-					this._updateRepr(quiet);
+					this._responseParts[responsePosition] = { content: new MarkdownString(content), kind: 'markdownContent' };
+				} else if (isMarkdownString(content)) {
+					this._responseParts[responsePosition] = { content, kind: 'markdownContent' };
+				} else {
+					this._responseParts[responsePosition] = content;
 				}
+				this._updateRepr(quiet);
 			});
-		} else if (isCompleteInteractiveProgressTreeData(responsePart)) {
-			this._responseParts.push(responsePart);
-			this._updateRepr(quiet);
-		} else if ('documents' in responsePart) {
-			this._usedContext = responsePart;
-		} else if ('reference' in responsePart) {
-			this._contentReferences.push(responsePart);
-			this._onDidChangeValue.fire();
-		} else if ('inlineReference' in responsePart) {
-			this._responseParts.push(responsePart);
+		} else if (progress.kind === 'treeData' || progress.kind === 'inlineReference') {
+			this._responseParts.push(progress);
 			this._updateRepr(quiet);
-		} else if ('agentName' in responsePart) {
-
 		}
 	}
 
 	private _updateRepr(quiet?: boolean) {
-		this._responseData = this._responseParts.map(part => {
-			if ('inlineReference' in part) {
-				return part;
-			} else if (isCompleteInteractiveProgressTreeData(part)) {
-				return part.treeData;
-			} else if (part.isPlaceholder) {
-				return { ...part.string, isPlaceholder: true };
-			}
-			return part.string;
-		});
-
 		this._responseRepr = this._responseParts.map(part => {
-			if (isCompleteInteractiveProgressTreeData(part)) {
+			if (part.kind === 'treeData') {
 				return '';
-			}
-			if ('inlineReference' in part) {
+			} else if (part.kind === 'inlineReference') {
 				return basename('uri' in part.inlineReference ? part.inlineReference.uri : part.inlineReference);
+			} else if (part.kind === 'asyncContent') {
+				return part.content;
+			} else {
+				return part.content.value;
 			}
-
-			return part.string.value;
 		}).join('\n\n');
 
 		if (!quiet) {
@@ -252,10 +191,6 @@ export class ChatResponseModel extends Disposable implements IChatResponseModel
 		return this._id;
 	}
 
-	public get providerResponseId(): string | undefined {
-		return this._providerResponseId;
-	}
-
 	public get isComplete(): boolean {
 		return this._isComplete;
 	}
@@ -305,6 +240,21 @@ export class ChatResponseModel extends Disposable implements IChatResponseModel
 		return this._slashCommand;
 	}
 
+	private _usedContext: IChatUsedContext | undefined;
+	public get usedContext(): IChatUsedContext | undefined {
+		return this._usedContext;
+	}
+
+	private readonly _contentReferences: IChatContentReference[] = [];
+	public get contentReferences(): ReadonlyArray<IChatContentReference> {
+		return this._contentReferences;
+	}
+
+	private readonly _progressMessages: IChatProgressMessage[] = [];
+	public get progressMessages(): ReadonlyArray<IChatProgressMessage> {
+		return this._progressMessages;
+	}
+
 	constructor(
 		_response: IMarkdownString | ReadonlyArray<IMarkdownString | IChatResponseProgressFileTreeData | IChatContentInlineReference>,
 		public readonly session: ChatModel,
@@ -313,7 +263,6 @@ export class ChatResponseModel extends Disposable implements IChatResponseModel
 		private _isComplete: boolean = false,
 		private _isCanceled = false,
 		private _vote?: InteractiveSessionVoteDirection,
-		private _providerResponseId?: string,
 		private _errorDetails?: IChatResponseErrorDetails,
 		followups?: ReadonlyArray<IChatFollowup>
 	) {
@@ -325,20 +274,34 @@ export class ChatResponseModel extends Disposable implements IChatResponseModel
 		this._id = 'response_' + ChatResponseModel.nextId++;
 	}
 
-	updateContent(responsePart: ResponsePart, quiet?: boolean) {
+	/**
+	 * Apply a progress update to the actual response content.
+	 */
+	updateContent(responsePart: IChatProgressResponseContent | IChatContent, quiet?: boolean) {
 		this._response.updateContent(responsePart, quiet);
 	}
 
+	/**
+	 * Apply one of the progress updates that are not part of the actual response content.
+	 */
+	applyProgress(progress: IChatUsedContext | IChatContentReference | IChatProgressMessage) {
+		if (progress.kind === 'usedContext') {
+			this._usedContext = progress;
+		} else if (progress.kind === 'reference') {
+			this._contentReferences.push(progress);
+			this._onDidChange.fire();
+		} else if (progress.kind === 'progressMessage') {
+			this._progressMessages.push(progress);
+			this._onDidChange.fire();
+		}
+	}
+
 	setAgent(agent: IChatAgentData, slashCommand?: IChatAgentCommand) {
 		this._agent = agent;
 		this._slashCommand = slashCommand;
 		this._onDidChange.fire();
 	}
 
-	setProviderResponseId(providerResponseId: string) {
-		this._providerResponseId = providerResponseId;
-	}
-
 	setErrorDetails(errorDetails?: IChatResponseErrorDetails): void {
 		this._errorDetails = errorDetails;
 		this._onDidChange.fire();
@@ -388,7 +351,6 @@ export interface ISerializableChatsData {
 export type ISerializableChatAgentData = UriDto<IChatAgentData>;
 
 export interface ISerializableChatRequestData {
-	providerRequestId: string | undefined;
 	message: string | IParsedChatRequest;
 	response: ReadonlyArray<IMarkdownString | IChatResponseProgressFileTreeData | IChatContentInlineReference> | undefined;
 	agent?: ISerializableChatAgentData;
@@ -398,7 +360,7 @@ export interface ISerializableChatRequestData {
 	isCanceled: boolean | undefined;
 	vote: InteractiveSessionVoteDirection | undefined;
 	/** For backward compat: should be optional */
-	usedContext?: IUsedContext;
+	usedContext?: IChatUsedContext;
 	contentReferences?: ReadonlyArray<IChatContentReference>;
 }
 
@@ -410,7 +372,6 @@ export interface IExportableChatData {
 	responderUsername: string;
 	requesterAvatarIconUri: UriComponents | undefined;
 	responderAvatarIconUri: UriComponents | undefined;
-	providerState: any;
 }
 
 export interface ISerializableChatData extends IExportableChatData {
@@ -486,11 +447,6 @@ export class ChatModel extends Disposable implements IChatModel {
 		return this._welcomeMessage;
 	}
 
-	private _providerState: any;
-	get providerState(): any {
-		return this._providerState;
-	}
-
 	// TODO to be clear, this is not the same as the id from the session object, which belongs to the provider.
 	// It's easier to be able to identify this model before its async initialization is complete
 	private _sessionId: string;
@@ -556,7 +512,6 @@ export class ChatModel extends Disposable implements IChatModel {
 		this._isImported = (!!initialData && !isSerializableSessionData(initialData)) || (initialData?.isImported ?? false);
 		this._sessionId = (isSerializableSessionData(initialData) && initialData.sessionId) || generateUuid();
 		this._requests = initialData ? this._deserialize(initialData) : [];
-		this._providerState = initialData ? initialData.providerState : undefined;
 		this._creationDate = (isSerializableSessionData(initialData) && initialData.creationDate) || Date.now();
 
 		this._initialRequesterAvatarIconUri = initialData?.requesterAvatarIconUri && URI.revive(initialData.requesterAvatarIconUri);
@@ -566,7 +521,7 @@ export class ChatModel extends Disposable implements IChatModel {
 	private _deserialize(obj: IExportableChatData): ChatRequestModel[] {
 		const requests = obj.requests;
 		if (!Array.isArray(requests)) {
-			this.logService.error(`Ignoring malformed session data: ${obj}`);
+			this.logService.error(`Ignoring malformed session data: ${JSON.stringify(obj)}`);
 			return [];
 		}
 
@@ -581,17 +536,17 @@ export class ChatModel extends Disposable implements IChatModel {
 					typeof raw.message === 'string'
 						? this.getParsedRequestFromString(raw.message)
 						: reviveParsedChatRequest(raw.message);
-				const request = new ChatRequestModel(this, parsedRequest, raw.providerRequestId);
+				const request = new ChatRequestModel(this, parsedRequest);
 				if (raw.response || raw.responseErrorDetails) {
 					const agent = (raw.agent && 'metadata' in raw.agent) ? // Check for the new format, ignore entries in the old format
 						revive<ISerializableChatAgentData>(raw.agent) : undefined;
-					request.response = new ChatResponseModel(raw.response ?? [new MarkdownString(raw.response)], this, agent, request.id, true, raw.isCanceled, raw.vote, raw.providerRequestId, raw.responseErrorDetails, raw.followups);
+					request.response = new ChatResponseModel(raw.response ?? [new MarkdownString(raw.response)], this, agent, request.id, true, raw.isCanceled, raw.vote, raw.responseErrorDetails, raw.followups);
 					if (raw.usedContext) { // @ulugbekna: if this's a new vscode sessions, doc versions are incorrect anyway?
-						request.response.updateContent(raw.usedContext);
+						request.response.applyProgress(raw.usedContext);
 					}
 
 					if (raw.contentReferences) {
-						raw.contentReferences.forEach(r => request.response!.updateContent(r));
+						raw.contentReferences.forEach(r => request.response!.applyProgress(r));
 					}
 				}
 				return request;
@@ -638,13 +593,6 @@ export class ChatModel extends Disposable implements IChatModel {
 		}
 
 		this._isInitializedDeferred.complete();
-
-		if (session.onDidChangeState) {
-			this._register(session.onDidChangeState(state => {
-				this._providerState = state;
-				this.logService.trace('ChatModel#acceptNewSessionState');
-			}));
-		}
 		this._onDidChange.fire({ kind: 'initialize' });
 	}
 
@@ -692,32 +640,26 @@ export class ChatModel extends Disposable implements IChatModel {
 			throw new Error('acceptResponseProgress: Adding progress to a completed response');
 		}
 
-		if ('content' in progress) {
-			request.response.updateContent(progress.content, quiet);
-		} else if ('placeholder' in progress || isCompleteInteractiveProgressTreeData(progress)) {
+		if (progress.kind === 'content' || progress.kind === 'markdownContent' || progress.kind === 'asyncContent' || progress.kind === 'treeData' || progress.kind === 'inlineReference') {
 			request.response.updateContent(progress, quiet);
-		} else if ('documents' in progress || 'reference' in progress || 'inlineReference' in progress) {
-			request.response.updateContent(progress);
-		} else if ('agentName' in progress) {
+		} else if (progress.kind === 'usedContext' || progress.kind === 'reference' || progress.kind === 'progressMessage') {
+			request.response.applyProgress(progress);
+		} else if (progress.kind === 'agentDetection') {
 			const agent = this.chatAgentService.getAgent(progress.agentName);
 			if (agent) {
 				request.response.setAgent(agent, progress.command);
 			}
 		} else {
-			request.setProviderRequestId(progress.requestId);
-			request.response.setProviderResponseId(progress.requestId);
+			this.logService.error(`Couldn't handle progress: ${JSON.stringify(progress)}`);
 		}
 	}
 
-	removeRequest(requestId: string): void {
-		const index = this._requests.findIndex(request => request.providerRequestId === requestId);
+	removeRequest(id: string): void {
+		const index = this._requests.findIndex(request => request.id === id);
 		const request = this._requests[index];
-		if (!request.providerRequestId) {
-			return;
-		}
 
 		if (index !== -1) {
-			this._onDidChange.fire({ kind: 'removeRequest', requestId: request.providerRequestId, responseId: request.response?.providerResponseId });
+			this._onDidChange.fire({ kind: 'removeRequest', requestId: request.id, responseId: request.response?.id });
 			this._requests.splice(index, 1);
 			request.response?.dispose();
 		}
@@ -778,21 +720,32 @@ export class ChatModel extends Disposable implements IChatModel {
 			}),
 			requests: this._requests.map((r): ISerializableChatRequestData => {
 				return {
-					providerRequestId: r.providerRequestId,
 					message: r.message,
-					response: r.response ? r.response.response.value : undefined,
+					response: r.response ?
+						r.response.response.value.map(item => {
+							// Keeping the shape of the persisted data the same for back compat
+							if (item.kind === 'treeData') {
+								return item.treeData;
+							} else if (item.kind === 'markdownContent') {
+								return item.content;
+							} else if (item.kind === 'asyncContent') {
+								return new MarkdownString(item.content);
+							} else {
+								return item;
+							}
+						})
+						: undefined,
 					responseErrorDetails: r.response?.errorDetails,
 					followups: r.response?.followups,
 					isCanceled: r.response?.isCanceled,
 					vote: r.response?.vote,
-					agent: r.response?.agent,
+					agent: r.response?.agent ? { id: r.response.agent.id, metadata: r.response.agent.metadata } : undefined, // May actually be the full IChatAgent instance, just take the data props
 					slashCommand: r.response?.slashCommand,
-					usedContext: r.response?.response.usedContext,
-					contentReferences: r.response?.response.contentReferences
+					usedContext: r.response?.usedContext,
+					contentReferences: r.response?.contentReferences
 				};
 			}),
 			providerId: this.providerId,
-			providerState: this._providerState
 		};
 	}
 
@@ -849,7 +802,3 @@ export class ChatWelcomeMessageModel implements IChatWelcomeMessageModel {
 		return this.session.responderAvatarIconUri;
 	}
 }
-
-export function isCompleteInteractiveProgressTreeData(item: unknown): item is { treeData: IChatResponseProgressFileTreeData } {
-	return typeof item === 'object' && !!item && 'treeData' in item;
-}
diff --git a/src/vs/workbench/contrib/csChat/common/csChatRequestParser.ts b/src/vs/workbench/contrib/csChat/common/csChatRequestParser.ts
index da606aac369..4a47172525c 100644
--- a/src/vs/workbench/contrib/csChat/common/csChatRequestParser.ts
+++ b/src/vs/workbench/contrib/csChat/common/csChatRequestParser.ts
@@ -9,7 +9,7 @@ import { IPosition, Position } from 'vs/editor/common/core/position';
 import { Range } from 'vs/editor/common/core/range';
 import { IChatAgentService } from 'vs/workbench/contrib/chat/common/chatAgents';
 import { ChatRequestAgentPart, ChatRequestAgentSubcommandPart, ChatRequestDynamicReferencePart, ChatRequestSlashCommandPart, ChatRequestTextPart, ChatRequestVariablePart, IParsedChatRequest, IParsedChatRequestPart, chatAgentLeader, chatSubcommandLeader, chatVariableLeader } from 'vs/workbench/contrib/chat/common/chatParserTypes';
-import { IChatService } from 'vs/workbench/contrib/chat/common/chatService';
+import { IChatSlashCommandService } from 'vs/workbench/contrib/chat/common/chatSlashCommands';
 import { IChatVariablesService, IDynamicReference } from 'vs/workbench/contrib/chat/common/chatVariables';
 
 const agentReg = /^@([\w_\-]+)(?=(\s|$|\b))/i; // An @-agent
@@ -21,7 +21,7 @@ export class ChatRequestParser {
 	constructor(
 		@IChatAgentService private readonly agentService: IChatAgentService,
 		@IChatVariablesService private readonly variableService: IChatVariablesService,
-		@IChatService private readonly chatService: IChatService,
+		@IChatSlashCommandService private readonly slashCommandService: IChatSlashCommandService
 	) { }
 
 	async parseChatRequest(sessionId: string, message: string): Promise<IParsedChatRequest> {
@@ -174,7 +174,7 @@ export class ChatRequestParser {
 				return new ChatRequestAgentSubcommandPart(slashRange, slashEditorRange, subCommand);
 			}
 		} else {
-			const slashCommands = await this.chatService.getSlashCommands(sessionId, CancellationToken.None);
+			const slashCommands = this.slashCommandService.getCommands();
 			const slashCommand = slashCommands.find(c => c.command === command);
 			if (slashCommand) {
 				// Valid standalone slash command
diff --git a/src/vs/workbench/contrib/csChat/common/csChatService.ts b/src/vs/workbench/contrib/csChat/common/csChatService.ts
index 24d969082d1..fcd5a652619 100644
--- a/src/vs/workbench/contrib/csChat/common/csChatService.ts
+++ b/src/vs/workbench/contrib/csChat/common/csChatService.ts
@@ -8,11 +8,11 @@ import { Event } from 'vs/base/common/event';
 import { IMarkdownString } from 'vs/base/common/htmlContent';
 import { IDisposable } from 'vs/base/common/lifecycle';
 import { URI } from 'vs/base/common/uri';
-import { Range, IRange } from 'vs/editor/common/core/range';
-import { ProviderResult, Location } from 'vs/editor/common/languages';
+import { IRange, Range } from 'vs/editor/common/core/range';
+import { Location, ProviderResult } from 'vs/editor/common/languages';
 import { createDecorator } from 'vs/platform/instantiation/common/instantiation';
 import { IChatAgentCommand, IChatAgentData } from 'vs/workbench/contrib/chat/common/chatAgents';
-import { IChatModel, ChatModel, ISerializableChatData } from 'vs/workbench/contrib/chat/common/chatModel';
+import { ChatModel, IChatModel, ISerializableChatData } from 'vs/workbench/contrib/chat/common/chatModel';
 import { IParsedChatRequest } from 'vs/workbench/contrib/chat/common/chatParserTypes';
 import { IChatRequestVariableValue } from 'vs/workbench/contrib/chat/common/chatVariables';
 
@@ -23,7 +23,6 @@ export interface IChat {
 	responderUsername: string;
 	responderAvatarIconUri?: URI;
 	inputPlaceholder?: string;
-	onDidChangeState?: Event<any>;
 	dispose?(): void;
 }
 
@@ -70,11 +69,12 @@ export function isIDocumentContext(obj: unknown): obj is IDocumentContext {
 	);
 }
 
-export type IUsedContext = {
+export interface IChatUsedContext {
 	documents: IDocumentContext[];
-};
+	kind: 'usedContext';
+}
 
-export function isIUsedContext(obj: unknown): obj is IUsedContext {
+export function isIUsedContext(obj: unknown): obj is IChatUsedContext {
 	return (
 		!!obj &&
 		typeof obj === 'object' &&
@@ -86,40 +86,68 @@ export function isIUsedContext(obj: unknown): obj is IUsedContext {
 
 export interface IChatContentReference {
 	reference: URI | Location;
+	kind: 'reference';
 }
 
 export interface IChatContentInlineReference {
 	inlineReference: URI | Location;
 	name?: string;
+	kind: 'inlineReference';
 }
 
 export interface IChatAgentDetection {
 	agentName: string;
 	command?: IChatAgentCommand;
+	kind: 'agentDetection';
+}
+
+export interface IChatContent {
+	content: string;
+	kind: 'content';
+}
+
+export interface IChatMarkdownContent {
+	content: IMarkdownString;
+	kind: 'markdownContent';
+}
+
+export interface IChatTreeData {
+	treeData: IChatResponseProgressFileTreeData;
+	kind: 'treeData';
+}
+
+export interface IChatAsyncContent {
+	/**
+	 * The placeholder to show while the content is loading
+	 */
+	content: string;
+	resolvedContent: Promise<string | IMarkdownString | IChatTreeData>;
+	kind: 'asyncContent';
+}
+
+export interface IChatProgressMessage {
+	content: string;
+	kind: 'progressMessage';
 }
 
 export type IChatProgress =
-	| { content: string | IMarkdownString }
-	| { requestId: string }
-	| { treeData: IChatResponseProgressFileTreeData }
-	| { placeholder: string; resolvedContent: Promise<string | IMarkdownString | { treeData: IChatResponseProgressFileTreeData }> }
-	| IUsedContext
+	| IChatContent
+	| IChatMarkdownContent
+	| IChatTreeData
+	| IChatAsyncContent
+	| IChatUsedContext
 	| IChatContentReference
 	| IChatContentInlineReference
-	| IChatAgentDetection;
+	| IChatAgentDetection
+	| IChatProgressMessage;
 
-export interface IPersistedChatState { }
 export interface IChatProvider {
 	readonly id: string;
 	readonly displayName: string;
 	readonly iconUrl?: string;
-	prepareSession(initialState: IPersistedChatState | undefined, token: CancellationToken): ProviderResult<IChat | undefined>;
+	prepareSession(token: CancellationToken): ProviderResult<IChat | undefined>;
 	provideWelcomeMessage?(token: CancellationToken): ProviderResult<(string | IMarkdownString | IChatReplyFollowup[])[] | undefined>;
 	provideSampleQuestions?(token: CancellationToken): ProviderResult<IChatReplyFollowup[] | undefined>;
-	provideFollowups?(session: IChat, token: CancellationToken): ProviderResult<IChatFollowup[] | undefined>;
-	provideReply(request: IChatRequest, progress: (progress: IChatProgress) => void, token: CancellationToken): ProviderResult<IChatResponse>;
-	provideSlashCommands?(session: IChat, token: CancellationToken): ProviderResult<ISlashCommand[]>;
-	removeRequest?(session: IChat, requestId: string): void;
 }
 
 export interface ISlashCommand {
@@ -156,7 +184,6 @@ export interface IChatReplyFollowup {
 	message: string;
 	title?: string;
 	tooltip?: string;
-	metadata?: any;
 }
 
 export interface IChatResponseCommandFollowup {
@@ -177,8 +204,8 @@ export enum InteractiveSessionVoteDirection {
 
 export interface IChatVoteAction {
 	kind: 'vote';
-	responseId: string;
 	direction: InteractiveSessionVoteDirection;
+	reportIssue?: boolean;
 }
 
 export enum InteractiveSessionCopyKind {
@@ -189,7 +216,6 @@ export enum InteractiveSessionCopyKind {
 
 export interface IChatCopyAction {
 	kind: 'copy';
-	responseId: string;
 	codeBlockIndex: number;
 	copyType: InteractiveSessionCopyKind;
 	copiedCharacters: number;
@@ -199,7 +225,6 @@ export interface IChatCopyAction {
 
 export interface IChatInsertAction {
 	kind: 'insert';
-	responseId: string;
 	codeBlockIndex: number;
 	totalCharacters: number;
 	newFile?: boolean;
@@ -207,7 +232,6 @@ export interface IChatInsertAction {
 
 export interface IChatTerminalAction {
 	kind: 'runInTerminal';
-	responseId: string;
 	codeBlockIndex: number;
 	languageId?: string;
 }
@@ -222,7 +246,11 @@ export interface IChatFollowupAction {
 	followup: IChatReplyFollowup;
 }
 
-export type ChatUserAction = IChatVoteAction | IChatCopyAction | IChatInsertAction | IChatTerminalAction | IChatCommandAction | IChatFollowupAction;
+export interface IChatBugReportAction {
+	kind: 'bug';
+}
+
+export type ChatUserAction = IChatVoteAction | IChatCopyAction | IChatInsertAction | IChatTerminalAction | IChatCommandAction | IChatFollowupAction | IChatBugReportAction;
 
 export interface IChatUserActionEvent {
 	action: ChatUserAction;
@@ -245,7 +273,7 @@ export interface IChatDynamicRequest {
 }
 
 export interface IChatCompleteResponse {
-	message: string | ReadonlyArray<IMarkdownString | IChatResponseProgressFileTreeData | IChatContentInlineReference>;
+	message: string | ReadonlyArray<IChatProgress>;
 	errorDetails?: IChatResponseErrorDetails;
 	followups?: IChatFollowup[];
 }
@@ -271,7 +299,7 @@ export interface IChatService {
 	_serviceBrand: undefined;
 	transferredSessionData: IChatTransferredSessionData | undefined;
 
-	onDidSubmitSlashCommand: Event<{ slashCommand: string; sessionId: string } | { agent: IChatAgentData; slashCommand: IChatAgentCommand; sessionId: string }>;
+	onDidSubmitAgent: Event<{ agent: IChatAgentData; slashCommand: IChatAgentCommand; sessionId: string }>;
 	onDidRegisterProvider: Event<{ providerId: string }>;
 	registerProvider(provider: IChatProvider): IDisposable;
 	hasSessions(providerId: string): boolean;
@@ -285,10 +313,9 @@ export interface IChatService {
 	/**
 	 * Returns whether the request was accepted.
 	 */
-	sendRequest(sessionId: string, message: string, usedSlashCommand?: ISlashCommand): Promise<{ responseCompletePromise: Promise<void> } | undefined>;
+	sendRequest(sessionId: string, message: string): Promise<{ responseCompletePromise: Promise<void> } | undefined>;
 	removeRequest(sessionid: string, requestId: string): Promise<void>;
 	cancelCurrentRequestForSession(sessionId: string): void;
-	getSlashCommands(sessionId: string, token: CancellationToken): Promise<ISlashCommand[]>;
 	clearSession(sessionId: string): void;
 	addCompleteRequest(sessionId: string, message: IParsedChatRequest | string, response: IChatCompleteResponse): void;
 	sendRequestToProvider(sessionId: string, message: IChatDynamicRequest): void;
diff --git a/src/vs/workbench/contrib/csChat/common/csChatServiceImpl.ts b/src/vs/workbench/contrib/csChat/common/csChatServiceImpl.ts
index 7b2154ffa31..9d447d5bbfc 100644
--- a/src/vs/workbench/contrib/csChat/common/csChatServiceImpl.ts
+++ b/src/vs/workbench/contrib/csChat/common/csChatServiceImpl.ts
@@ -6,9 +6,9 @@
 import { CancelablePromise, createCancelablePromise } from 'vs/base/common/async';
 import { CancellationToken } from 'vs/base/common/cancellation';
 import { Emitter, Event } from 'vs/base/common/event';
-import { MarkdownString, isMarkdownString } from 'vs/base/common/htmlContent';
+import { MarkdownString } from 'vs/base/common/htmlContent';
 import { Iterable } from 'vs/base/common/iterator';
-import { Disposable, IDisposable, toDisposable } from 'vs/base/common/lifecycle';
+import { Disposable, DisposableMap, IDisposable, toDisposable } from 'vs/base/common/lifecycle';
 import { revive } from 'vs/base/common/marshalling';
 import { StopWatch } from 'vs/base/common/stopwatch';
 import { URI, UriComponents } from 'vs/base/common/uri';
@@ -23,12 +23,12 @@ import { ITelemetryService } from 'vs/platform/telemetry/common/telemetry';
 import { IWorkspaceContextService } from 'vs/platform/workspace/common/workspace';
 import { IChatAgentCommand, IChatAgentData, IChatAgentRequest, IChatAgentService } from 'vs/workbench/contrib/chat/common/chatAgents';
 import { CONTEXT_PROVIDER_EXISTS } from 'vs/workbench/contrib/chat/common/chatContextKeys';
-import { ChatModel, ChatModelInitState, ChatRequestModel, ChatWelcomeMessageModel, IChatModel, ISerializableChatData, ISerializableChatsData, isCompleteInteractiveProgressTreeData } from 'vs/workbench/contrib/chat/common/chatModel';
+import { ChatModel, ChatModelInitState, ChatRequestModel, ChatWelcomeMessageModel, IChatModel, ISerializableChatData, ISerializableChatsData } from 'vs/workbench/contrib/chat/common/chatModel';
 import { ChatRequestAgentPart, ChatRequestAgentSubcommandPart, ChatRequestSlashCommandPart } from 'vs/workbench/contrib/chat/common/chatParserTypes';
 import { ChatMessageRole, IChatMessage } from 'vs/workbench/contrib/chat/common/chatProvider';
 import { ChatRequestParser } from 'vs/workbench/contrib/chat/common/chatRequestParser';
-import { IChat, IChatCompleteResponse, IChatDetail, IChatDynamicRequest, IChatFollowup, IChatProgress, IChatProvider, IChatProviderInfo, IChatRequest, IChatResponse, IChatService, IChatTransferredSessionData, IChatUserActionEvent, ISlashCommand, InteractiveSessionCopyKind, InteractiveSessionVoteDirection } from 'vs/workbench/contrib/chat/common/chatService';
-import { IChatSlashCommandService, IChatSlashFragment } from 'vs/workbench/contrib/chat/common/chatSlashCommands';
+import { IChat, IChatCompleteResponse, IChatDetail, IChatDynamicRequest, IChatFollowup, IChatProgress, IChatProvider, IChatProviderInfo, IChatResponse, IChatService, IChatTransferredSessionData, IChatUserActionEvent, InteractiveSessionCopyKind, InteractiveSessionVoteDirection } from 'vs/workbench/contrib/chat/common/chatService';
+import { IChatSlashCommandService } from 'vs/workbench/contrib/chat/common/chatSlashCommands';
 import { IChatVariablesService } from 'vs/workbench/contrib/chat/common/chatVariables';
 import { IExtensionService } from 'vs/workbench/services/extensions/common/extensions';
 
@@ -134,7 +134,7 @@ export class ChatService extends Disposable implements IChatService {
 
 	private readonly _providers = new Map<string, IChatProvider>();
 
-	private readonly _sessionModels = new Map<string, ChatModel>();
+	private readonly _sessionModels = this._register(new DisposableMap<string, ChatModel>());
 	private readonly _pendingRequests = new Map<string, CancelablePromise<void>>();
 	private readonly _persistedSessions: ISerializableChatsData;
 	private readonly _hasProvider: IContextKey<boolean>;
@@ -147,8 +147,8 @@ export class ChatService extends Disposable implements IChatService {
 	private readonly _onDidPerformUserAction = this._register(new Emitter<IChatUserActionEvent>());
 	public readonly onDidPerformUserAction: Event<IChatUserActionEvent> = this._onDidPerformUserAction.event;
 
-	private readonly _onDidSubmitSlashCommand = this._register(new Emitter<{ slashCommand: string; sessionId: string } | { agent: IChatAgentData; slashCommand: IChatAgentCommand; sessionId: string }>());
-	public readonly onDidSubmitSlashCommand = this._onDidSubmitSlashCommand.event;
+	private readonly _onDidSubmitAgent = this._register(new Emitter<{ agent: IChatAgentData; slashCommand: IChatAgentCommand; sessionId: string }>());
+	public readonly onDidSubmitAgent = this._onDidSubmitAgent.event;
 
 	private readonly _onDidDisposeSession = this._register(new Emitter<{ sessionId: string; providerId: string; reason: 'initializationFailed' | 'cleared' }>());
 	public readonly onDidDisposeSession = this._onDidDisposeSession.event;
@@ -306,6 +306,12 @@ export class ChatService extends Disposable implements IChatService {
 		return transferred;
 	}
 
+	/**
+	 * Returns an array of chat details for all persisted chat sessions that have at least one request.
+	 * The array is sorted by creation date in descending order.
+	 * Chat sessions that have already been loaded into the chat view are excluded from the result.
+	 * Imported chat sessions are also excluded from the result.
+	 */
 	getHistory(): IChatDetail[] {
 		const sessions = Object.values(this._persistedSessions)
 			.filter(session => session.requests.length > 0);
@@ -359,7 +365,7 @@ export class ChatService extends Disposable implements IChatService {
 
 			let session: IChat | undefined;
 			try {
-				session = await provider.prepareSession(model.providerState, token) ?? undefined;
+				session = await provider.prepareSession(token) ?? undefined;
 			} catch (err) {
 				this.trace('initializeSession', `Provider initializeSession threw: ${err}`);
 			}
@@ -381,8 +387,7 @@ export class ChatService extends Disposable implements IChatService {
 		} catch (err) {
 			this.trace('startSession', `initializeSession failed: ${err}`);
 			model.setInitializationError(err);
-			model.dispose();
-			this._sessionModels.delete(model.sessionId);
+			this._sessionModels.deleteAndDispose(model.sessionId);
 			this._onDidDisposeSession.fire({ sessionId: model.sessionId, providerId: model.providerId, reason: 'initializationFailed' });
 		}
 	}
@@ -418,7 +423,7 @@ export class ChatService extends Disposable implements IChatService {
 		return this._startSession(data.providerId, data, CancellationToken.None);
 	}
 
-	async sendRequest(sessionId: string, request: string, usedSlashCommand?: ISlashCommand): Promise<{ responseCompletePromise: Promise<void> } | undefined> {
+	async sendRequest(sessionId: string, request: string): Promise<{ responseCompletePromise: Promise<void> } | undefined> {
 		this.trace('sendRequest', `sessionId: ${sessionId}, message: ${request.substring(0, 20)}${request.length > 20 ? '[...]' : ''}}`);
 		if (!request.trim()) {
 			this.trace('sendRequest', 'Rejected empty message');
@@ -442,10 +447,10 @@ export class ChatService extends Disposable implements IChatService {
 		}
 
 		// This method is only returning whether the request was accepted - don't block on the actual request
-		return { responseCompletePromise: this._sendRequestAsync(model, sessionId, provider, request, usedSlashCommand) };
+		return { responseCompletePromise: this._sendRequestAsync(model, sessionId, provider, request) };
 	}
 
-	private async _sendRequestAsync(model: ChatModel, sessionId: string, provider: IChatProvider, message: string, usedSlashCommand?: ISlashCommand): Promise<void> {
+	private async _sendRequestAsync(model: ChatModel, sessionId: string, provider: IChatProvider, message: string): Promise<void> {
 		const parsedRequest = await this.instantiationService.createInstance(ChatRequestParser).parseChatRequest(sessionId, message);
 
 		let request: ChatRequestModel;
@@ -464,23 +469,10 @@ export class ChatService extends Disposable implements IChatService {
 
 				gotProgress = true;
 
-				if ('content' in progress) {
+				if (progress.kind === 'content' || progress.kind === 'markdownContent') {
 					this.trace('sendRequest', `Provider returned progress for session ${model.sessionId}, ${typeof progress.content === 'string' ? progress.content.length : progress.content.value.length} chars`);
-				} else if ('placeholder' in progress) {
-					this.trace('sendRequest', `Provider returned placeholder for session ${model.sessionId}, ${progress.placeholder}`);
-				} else if (isCompleteInteractiveProgressTreeData(progress)) {
-					// This isn't exposed in API
-					this.trace('sendRequest', `Provider returned tree data for session ${model.sessionId}, ${progress.treeData.label}`);
-				} else if ('documents' in progress) {
-					this.trace('sendRequest', `Provider returned documents for session ${model.sessionId}:\n ${JSON.stringify(progress.documents, null, '\t')}`);
-				} else if ('reference' in progress) {
-					this.trace('sendRequest', `Provider returned a reference for session ${model.sessionId}:\n ${JSON.stringify(progress.reference, null, '\t')}`);
-				} else if ('inlineReference' in progress) {
-					this.trace('sendRequest', `Provider returned an inline reference for session ${model.sessionId}:\n ${JSON.stringify(progress.inlineReference, null, '\t')}`);
-				} else if ('agentName' in progress) {
-					this.trace('sendRequest', `Provider returned an agent detection for session ${model.sessionId}:\n ${JSON.stringify(progress, null, '\t')}`);
 				} else {
-					this.trace('sendRequest', `Provider returned id for session ${model.sessionId}, ${progress.requestId}`);
+					this.trace('sendRequest', `Provider returned progress: ${JSON.stringify(progress)}`);
 				}
 
 				model.acceptResponseProgress(request, progress);
@@ -497,7 +489,7 @@ export class ChatService extends Disposable implements IChatService {
 					result: 'cancelled',
 					requestType,
 					agent: agentPart?.agent.id ?? '',
-					slashCommand: agentSlashCommandPart ? agentSlashCommandPart.command.name : usedSlashCommand?.command,
+					slashCommand: agentSlashCommandPart ? agentSlashCommandPart.command.name : commandPart?.slashCommand.command,
 					chatSessionId: model.sessionId
 				});
 
@@ -505,10 +497,8 @@ export class ChatService extends Disposable implements IChatService {
 			});
 
 			try {
-				if (usedSlashCommand?.command) {
-					this._onDidSubmitSlashCommand.fire({ slashCommand: usedSlashCommand.command, sessionId: model.sessionId });
-				} else if (agentPart && agentSlashCommandPart?.command) {
-					this._onDidSubmitSlashCommand.fire({ agent: agentPart.agent, slashCommand: agentSlashCommandPart.command, sessionId: model.sessionId });
+				if (agentPart && agentSlashCommandPart?.command) {
+					this._onDidSubmitAgent.fire({ agent: agentPart.agent, slashCommand: agentSlashCommandPart.command, sessionId: model.sessionId });
 				}
 
 				let rawResponse: IChatResponse | null | undefined;
@@ -561,28 +551,14 @@ export class ChatService extends Disposable implements IChatService {
 						history.push({ role: ChatMessageRole.User, content: request.message.text });
 						history.push({ role: ChatMessageRole.Assistant, content: request.response.response.asString() });
 					}
-					const commandResult = await this.chatSlashCommandService.executeCommand(commandPart.slashCommand.command, message.substring(commandPart.slashCommand.command.length + 1).trimStart(), new Progress<IChatSlashFragment>(p => {
-						const { content } = p;
-						const data = isCompleteInteractiveProgressTreeData(content) ? content : { content };
-						progressCallback(data);
+					const commandResult = await this.chatSlashCommandService.executeCommand(commandPart.slashCommand.command, message.substring(commandPart.slashCommand.command.length + 1).trimStart(), new Progress<IChatProgress>(p => {
+						progressCallback(p);
 					}), history, token);
 					agentOrCommandFollowups = Promise.resolve(commandResult?.followUp);
 					rawResponse = { session: model.session! };
 
 				} else {
-					request = model.addRequest(parsedRequest);
-					const requestProps: IChatRequest = {
-						session: model.session!,
-						message,
-						variables: {}
-					};
-
-					if ('parts' in parsedRequest) {
-						const varResult = await this.chatVariablesService.resolveVariables(parsedRequest, model, token);
-						requestProps.variables = varResult.variables;
-						requestProps.message = varResult.prompt;
-					}
-					rawResponse = await provider.provideReply(requestProps, progressCallback, token);
+					throw new Error(`Can't handle request`);
 				}
 
 				if (token.isCancellationRequested) {
@@ -604,7 +580,7 @@ export class ChatService extends Disposable implements IChatService {
 						result,
 						requestType,
 						agent: agentPart?.agent.id ?? '',
-						slashCommand: agentSlashCommandPart ? agentSlashCommandPart.command.name : usedSlashCommand?.command,
+						slashCommand: agentSlashCommandPart ? agentSlashCommandPart.command.name : commandPart?.slashCommand.command,
 						chatSessionId: model.sessionId
 					});
 					model.setResponse(request, rawResponse);
@@ -616,11 +592,6 @@ export class ChatService extends Disposable implements IChatService {
 							model.setFollowups(request, followups);
 							model.completeResponse(request);
 						});
-					} else if (provider.provideFollowups) {
-						Promise.resolve(provider.provideFollowups(model.session!, CancellationToken.None)).then(providerFollowups => {
-							model.setFollowups(request, providerFollowups ?? undefined);
-							model.completeResponse(request);
-						});
 					} else {
 						model.completeResponse(request);
 					}
@@ -649,43 +620,6 @@ export class ChatService extends Disposable implements IChatService {
 		}
 
 		model.removeRequest(requestId);
-		provider.removeRequest?.(model.session!, requestId);
-	}
-
-	async getSlashCommands(sessionId: string, token: CancellationToken): Promise<ISlashCommand[]> {
-		const model = this._sessionModels.get(sessionId);
-		if (!model) {
-			throw new Error(`Unknown session: ${sessionId}`);
-		}
-
-		await model.waitForInitialization();
-		const provider = this._providers.get(model.providerId);
-		if (!provider) {
-			throw new Error(`Unknown provider: ${model.providerId}`);
-		}
-
-		const serviceResults = this.chatSlashCommandService.getCommands().map(data => {
-			return <ISlashCommand>{
-				command: data.command,
-				detail: data.detail,
-				sortText: data.sortText,
-				executeImmediately: data.executeImmediately
-			};
-		});
-
-		const mainProviderRequest = provider.provideSlashCommands?.(model.session!, token);
-
-		try {
-			const providerResults = await mainProviderRequest;
-			if (providerResults) {
-				return providerResults.concat(serviceResults);
-			}
-			return serviceResults;
-
-		} catch (e) {
-			this.logService.error(e);
-			return serviceResults;
-		}
 	}
 
 	async sendRequestToProvider(sessionId: string, message: IChatDynamicRequest): Promise<{ responseCompletePromise: Promise<void> } | undefined> {
@@ -709,13 +643,10 @@ export class ChatService extends Disposable implements IChatService {
 		const parsedRequest = await this.instantiationService.createInstance(ChatRequestParser).parseChatRequest(sessionId, message);
 		const request = model.addRequest(parsedRequest);
 		if (typeof response.message === 'string') {
-			model.acceptResponseProgress(request, { content: response.message });
+			model.acceptResponseProgress(request, { content: response.message, kind: 'content' });
 		} else {
 			for (const part of response.message) {
-				const progress = 'inlineReference' in part ? part :
-					isMarkdownString(part) ? { content: part.value } :
-						{ treeData: part };
-				model.acceptResponseProgress(request, progress, true);
+				model.acceptResponseProgress(request, part, true);
 			}
 		}
 		model.setResponse(request, {
@@ -742,8 +673,7 @@ export class ChatService extends Disposable implements IChatService {
 
 		this._persistedSessions[sessionId] = model.toJSON();
 
-		model.dispose();
-		this._sessionModels.delete(sessionId);
+		this._sessionModels.deleteAndDispose(sessionId);
 		this._pendingRequests.get(sessionId)?.cancel();
 		this._onDidDisposeSession.fire({ sessionId, providerId: model.providerId, reason: 'cleared' });
 	}
diff --git a/src/vs/workbench/contrib/csChat/common/csChatSlashCommands.ts b/src/vs/workbench/contrib/csChat/common/csChatSlashCommands.ts
index e7bbdf2b299..3d758da3113 100644
--- a/src/vs/workbench/contrib/csChat/common/csChatSlashCommands.ts
+++ b/src/vs/workbench/contrib/csChat/common/csChatSlashCommands.ts
@@ -5,11 +5,11 @@
 
 import { CancellationToken } from 'vs/base/common/cancellation';
 import { Emitter, Event } from 'vs/base/common/event';
-import { Disposable, IDisposable, combinedDisposable, toDisposable } from 'vs/base/common/lifecycle';
+import { Disposable, IDisposable, toDisposable } from 'vs/base/common/lifecycle';
 import { createDecorator } from 'vs/platform/instantiation/common/instantiation';
 import { IProgress } from 'vs/platform/progress/common/progress';
 import { IChatMessage } from 'vs/workbench/contrib/chat/common/chatProvider';
-import { IChatFollowup, IChatResponseProgressFileTreeData } from 'vs/workbench/contrib/chat/common/chatService';
+import { IChatFollowup, IChatProgress, IChatResponseProgressFileTreeData } from 'vs/workbench/contrib/chat/common/chatService';
 import { IExtensionService } from 'vs/workbench/services/extensions/common/extensions';
 
 //#region slash service, commands etc
@@ -29,21 +29,18 @@ export interface IChatSlashData {
 export interface IChatSlashFragment {
 	content: string | { treeData: IChatResponseProgressFileTreeData };
 }
-
-export type IChatSlashCallback = { (prompt: string, progress: IProgress<IChatSlashFragment>, history: IChatMessage[], token: CancellationToken): Promise<{ followUp: IChatFollowup[] } | void> };
+export type IChatSlashCallback = { (prompt: string, progress: IProgress<IChatProgress>, history: IChatMessage[], token: CancellationToken): Promise<{ followUp: IChatFollowup[] } | void> };
 
 export const IChatSlashCommandService = createDecorator<IChatSlashCommandService>('chatSlashCommandService');
 
 /**
- * This currently only exists to drive /clear. Delete this when the agent service can handle that scenario
+ * This currently only exists to drive /clear and /help
  */
 export interface IChatSlashCommandService {
 	_serviceBrand: undefined;
 	readonly onDidChangeCommands: Event<void>;
-	registerSlashData(data: IChatSlashData): IDisposable;
-	registerSlashCallback(id: string, command: IChatSlashCallback): IDisposable;
 	registerSlashCommand(data: IChatSlashData, command: IChatSlashCallback): IDisposable;
-	executeCommand(id: string, prompt: string, progress: IProgress<IChatSlashFragment>, history: IChatMessage[], token: CancellationToken): Promise<{ followUp: IChatFollowup[] } | void>;
+	executeCommand(id: string, prompt: string, progress: IProgress<IChatProgress>, history: IChatMessage[], token: CancellationToken): Promise<{ followUp: IChatFollowup[] } | void>;
 	getCommands(): Array<IChatSlashData>;
 	hasCommand(id: string): boolean;
 }
@@ -68,11 +65,12 @@ export class ChatSlashCommandService extends Disposable implements IChatSlashCom
 		this._commands.clear();
 	}
 
-	registerSlashData(data: IChatSlashData): IDisposable {
+	registerSlashCommand(data: IChatSlashData, command: IChatSlashCallback): IDisposable {
 		if (this._commands.has(data.command)) {
 			throw new Error(`Already registered a command with id ${data.command}}`);
 		}
-		this._commands.set(data.command, { data });
+
+		this._commands.set(data.command, { data, command });
 		this._onDidChangeCommands.fire();
 
 		return toDisposable(() => {
@@ -82,22 +80,6 @@ export class ChatSlashCommandService extends Disposable implements IChatSlashCom
 		});
 	}
 
-	registerSlashCallback(id: string, command: IChatSlashCallback): IDisposable {
-		const data = this._commands.get(id);
-		if (!data) {
-			throw new Error(`No command with id ${id} registered`);
-		}
-		data.command = command;
-		return toDisposable(() => data.command = undefined);
-	}
-
-	registerSlashCommand(data: IChatSlashData, command: IChatSlashCallback): IDisposable {
-		return combinedDisposable(
-			this.registerSlashData(data),
-			this.registerSlashCallback(data.command, command)
-		);
-	}
-
 	getCommands(): Array<IChatSlashData> {
 		return Array.from(this._commands.values(), v => v.data);
 	}
@@ -106,7 +88,7 @@ export class ChatSlashCommandService extends Disposable implements IChatSlashCom
 		return this._commands.has(id);
 	}
 
-	async executeCommand(id: string, prompt: string, progress: IProgress<IChatSlashFragment>, history: IChatMessage[], token: CancellationToken): Promise<{ followUp: IChatFollowup[] } | void> {
+	async executeCommand(id: string, prompt: string, progress: IProgress<IChatProgress>, history: IChatMessage[], token: CancellationToken): Promise<{ followUp: IChatFollowup[] } | void> {
 		const data = this._commands.get(id);
 		if (!data) {
 			throw new Error('No command with id ${id} NOT registered');
diff --git a/src/vs/workbench/contrib/csChat/common/csChatViewModel.ts b/src/vs/workbench/contrib/csChat/common/csChatViewModel.ts
index d6337756df3..6fba224d47f 100644
--- a/src/vs/workbench/contrib/csChat/common/csChatViewModel.ts
+++ b/src/vs/workbench/contrib/csChat/common/csChatViewModel.ts
@@ -11,7 +11,7 @@ import { ILogService } from 'vs/platform/log/common/log';
 import { IChatAgentCommand, IChatAgentData } from 'vs/workbench/contrib/chat/common/chatAgents';
 import { ChatModelInitState, IChatModel, IChatRequestModel, IChatResponseModel, IChatWelcomeMessageContent, IResponse } from 'vs/workbench/contrib/chat/common/chatModel';
 import { IParsedChatRequest } from 'vs/workbench/contrib/chat/common/chatParserTypes';
-import { IChatReplyFollowup, IChatResponseCommandFollowup, IChatResponseErrorDetails, IChatResponseProgressFileTreeData, InteractiveSessionVoteDirection } from 'vs/workbench/contrib/chat/common/chatService';
+import { IChatContentReference, IChatProgressMessage, IChatReplyFollowup, IChatResponseCommandFollowup, IChatResponseErrorDetails, IChatResponseProgressFileTreeData, IChatUsedContext, InteractiveSessionVoteDirection } from 'vs/workbench/contrib/chat/common/chatService';
 import { countWords } from 'vs/workbench/contrib/chat/common/chatWordCounter';
 
 export function isRequestVM(item: unknown): item is IChatRequestViewModel {
@@ -55,7 +55,6 @@ export interface IChatViewModel {
 
 export interface IChatRequestViewModel {
 	readonly id: string;
-	readonly providerRequestId: string | undefined;
 	readonly sessionId: string;
 	/** This ID updates every time the underlying data changes */
 	readonly dataId: string;
@@ -88,7 +87,6 @@ export interface IChatResponseViewModel {
 	/** This ID updates every time the underlying data changes */
 	readonly dataId: string;
 	readonly providerId: string;
-	readonly providerResponseId: string | undefined;
 	/** The ID of the associated IChatRequestViewModel */
 	readonly requestId: string;
 	readonly username: string;
@@ -96,6 +94,9 @@ export interface IChatResponseViewModel {
 	readonly agent?: IChatAgentData;
 	readonly slashCommand?: IChatAgentCommand;
 	readonly response: IResponse;
+	readonly usedContext: IChatUsedContext | undefined;
+	readonly contentReferences: ReadonlyArray<IChatContentReference>;
+	readonly progressMessages: ReadonlyArray<IChatProgressMessage>;
 	readonly isComplete: boolean;
 	readonly isCanceled: boolean;
 	readonly vote: InteractiveSessionVoteDirection | undefined;
@@ -173,12 +174,12 @@ export class ChatViewModel extends Disposable implements IChatViewModel {
 			} else if (e.kind === 'addResponse') {
 				this.onAddResponse(e.response);
 			} else if (e.kind === 'removeRequest') {
-				const requestIdx = this._items.findIndex(item => isRequestVM(item) && item.providerRequestId === e.requestId);
+				const requestIdx = this._items.findIndex(item => isRequestVM(item) && item.id === e.requestId);
 				if (requestIdx >= 0) {
 					this._items.splice(requestIdx, 1);
 				}
 
-				const responseIdx = e.responseId && this._items.findIndex(item => isResponseVM(item) && item.providerResponseId === e.responseId);
+				const responseIdx = e.responseId && this._items.findIndex(item => isResponseVM(item) && item.id === e.responseId);
 				if (typeof responseIdx === 'number' && responseIdx >= 0) {
 					const items = this._items.splice(responseIdx, 1);
 					const item = items[0];
@@ -218,10 +219,6 @@ export class ChatRequestViewModel implements IChatRequestViewModel {
 		return this._model.id;
 	}
 
-	get providerRequestId() {
-		return this._model.providerRequestId;
-	}
-
 	get dataId() {
 		return this.id + `_${ChatModelInitState[this._model.session.initState]}`;
 	}
@@ -269,10 +266,6 @@ export class ChatResponseViewModel extends Disposable implements IChatResponseVi
 		return this._model.providerId;
 	}
 
-	get providerResponseId() {
-		return this._model.providerResponseId;
-	}
-
 	get sessionId() {
 		return this._model.session.sessionId;
 	}
@@ -297,6 +290,18 @@ export class ChatResponseViewModel extends Disposable implements IChatResponseVi
 		return this._model.response;
 	}
 
+	get usedContext(): IChatUsedContext | undefined {
+		return this._model.usedContext;
+	}
+
+	get contentReferences(): ReadonlyArray<IChatContentReference> {
+		return this._model.contentReferences;
+	}
+
+	get progressMessages(): ReadonlyArray<IChatProgressMessage> {
+		return this._model.progressMessages;
+	}
+
 	get isComplete() {
 		return this._model.isComplete;
 	}
diff --git a/src/vs/workbench/contrib/csChat/electron-sandbox/actions/csVoiceChatActions.ts b/src/vs/workbench/contrib/csChat/electron-sandbox/actions/csVoiceChatActions.ts
index c8fbc962176..e82a6afea81 100644
--- a/src/vs/workbench/contrib/csChat/electron-sandbox/actions/csVoiceChatActions.ts
+++ b/src/vs/workbench/contrib/csChat/electron-sandbox/actions/csVoiceChatActions.ts
@@ -18,7 +18,7 @@ import { spinningLoading } from 'vs/platform/theme/common/iconRegistry';
 import { CHAT_CATEGORY } from 'vs/workbench/contrib/chat/browser/actions/chatActions';
 import { IChatWidget, IChatWidgetService, IQuickChatService } from 'vs/workbench/contrib/chat/browser/chat';
 import { IChatService } from 'vs/workbench/contrib/chat/common/chatService';
-import { MENU_INLINE_CHAT_WIDGET } from 'vs/workbench/contrib/inlineChat/common/inlineChat';
+import { CTX_INLINE_CHAT_HAS_ACTIVE_REQUEST, MENU_INLINE_CHAT_WIDGET } from 'vs/workbench/contrib/inlineChat/common/inlineChat';
 import { CONTEXT_CHAT_REQUEST_IN_PROGRESS, CONTEXT_PROVIDER_EXISTS } from 'vs/workbench/contrib/chat/common/chatContextKeys';
 import { InlineChatController } from 'vs/workbench/contrib/inlineChat/browser/inlineChatController';
 import { IEditorService } from 'vs/workbench/services/editor/common/editorService';
@@ -29,7 +29,6 @@ import { IViewsService } from 'vs/workbench/common/views';
 import { IChatContributionService } from 'vs/workbench/contrib/chat/common/chatContributionService';
 import { KeybindingWeight } from 'vs/platform/keybinding/common/keybindingsRegistry';
 import { KeyCode } from 'vs/base/common/keyCodes';
-import { isExecuteActionContext } from 'vs/workbench/contrib/chat/browser/actions/chatExecuteActions';
 import { IWorkbenchLayoutService, Parts } from 'vs/workbench/services/layout/browser/layoutService';
 import { HasSpeechProvider, ISpeechService, SpeechToTextStatus } from 'vs/workbench/contrib/speech/common/speechService';
 import { RunOnceScheduler } from 'vs/base/common/async';
@@ -38,6 +37,10 @@ import { ACTIVITY_BAR_BADGE_BACKGROUND } from 'vs/workbench/common/theme';
 import { ColorScheme } from 'vs/platform/theme/common/theme';
 import { Color } from 'vs/base/common/color';
 import { contrastBorder, focusBorder } from 'vs/platform/theme/common/colorRegistry';
+import { IConfigurationService } from 'vs/platform/configuration/common/configuration';
+import { isNumber } from 'vs/base/common/types';
+import { AccessibilityVoiceSettingId, SpeechTimeoutDefault } from 'vs/workbench/contrib/accessibility/browser/accessibilityConfiguration';
+import { IChatExecuteActionContext } from 'vs/workbench/contrib/chat/browser/actions/chatExecuteActions';
 
 const CONTEXT_VOICE_CHAT_GETTING_READY = new RawContextKey<boolean>('voiceChatGettingReady', false, { type: 'boolean', description: localize('voiceChatGettingReady', "True when getting ready for receiving voice input from the microphone for voice chat.") });
 const CONTEXT_VOICE_CHAT_IN_PROGRESS = new RawContextKey<boolean>('voiceChatInProgress', false, { type: 'boolean', description: localize('voiceChatInProgress', "True when voice recording from microphone is in progress for voice chat.") });
@@ -237,7 +240,8 @@ class VoiceChatSessions {
 
 	constructor(
 		@IContextKeyService private readonly contextKeyService: IContextKeyService,
-		@ISpeechService private readonly speechService: ISpeechService
+		@ISpeechService private readonly speechService: ISpeechService,
+		@IConfigurationService private readonly configurationService: IConfigurationService
 	) { }
 
 	async start(controller: IVoiceChatSessionController): Promise<void> {
@@ -263,7 +267,13 @@ class VoiceChatSessions {
 		const speechToTextSession = session.disposables.add(this.speechService.createSpeechToTextSession(cts.token));
 
 		let inputValue = controller.getInput();
-		const acceptTranscriptionScheduler = session.disposables.add(new RunOnceScheduler(() => session.controller.acceptInput(), 1200));
+
+		let voiceChatTimeout = this.configurationService.getValue<number>(AccessibilityVoiceSettingId.SpeechTimeout);
+		if (!isNumber(voiceChatTimeout) || voiceChatTimeout < 0) {
+			voiceChatTimeout = SpeechTimeoutDefault;
+		}
+
+		const acceptTranscriptionScheduler = session.disposables.add(new RunOnceScheduler(() => session.controller.acceptInput(), voiceChatTimeout));
 		session.disposables.add(speechToTextSession.onDidChange(({ status, text }) => {
 			if (cts.token.isCancellationRequested) {
 				return;
@@ -276,14 +286,18 @@ class VoiceChatSessions {
 				case SpeechToTextStatus.Recognizing:
 					if (text) {
 						session.controller.updateInput([inputValue, text].join(' '));
-						acceptTranscriptionScheduler.cancel();
+						if (voiceChatTimeout > 0) {
+							acceptTranscriptionScheduler.cancel();
+						}
 					}
 					break;
 				case SpeechToTextStatus.Recognized:
 					if (text) {
 						inputValue = [inputValue, text].join(' ');
 						session.controller.updateInput(inputValue);
-						acceptTranscriptionScheduler.schedule();
+						if (voiceChatTimeout > 0) {
+							acceptTranscriptionScheduler.schedule();
+						}
 					}
 					break;
 				case SpeechToTextStatus.Stopped:
@@ -453,7 +467,7 @@ export class StartVoiceChatAction extends Action2 {
 			},
 			category: CHAT_CATEGORY,
 			icon: Codicon.mic,
-			precondition: ContextKeyExpr.and(HasSpeechProvider, CONTEXT_VOICE_CHAT_GETTING_READY.negate(), CONTEXT_CHAT_REQUEST_IN_PROGRESS.negate()),
+			precondition: ContextKeyExpr.and(HasSpeechProvider, CONTEXT_VOICE_CHAT_GETTING_READY.negate(), CONTEXT_CHAT_REQUEST_IN_PROGRESS.negate(), CTX_INLINE_CHAT_HAS_ACTIVE_REQUEST.negate()),
 			menu: [{
 				id: MenuId.ChatExecute,
 				when: ContextKeyExpr.and(HasSpeechProvider, CONTEXT_VOICE_CHAT_IN_VIEW_IN_PROGRESS.negate(), CONTEXT_QUICK_VOICE_CHAT_IN_PROGRESS.negate(), CONTEXT_VOICE_CHAT_IN_EDITOR_IN_PROGRESS.negate()),
@@ -472,7 +486,8 @@ export class StartVoiceChatAction extends Action2 {
 		const instantiationService = accessor.get(IInstantiationService);
 		const commandService = accessor.get(ICommandService);
 
-		if (isExecuteActionContext(context)) {
+		const widget = (context as IChatExecuteActionContext)?.widget;
+		if (widget) {
 			// if we already get a context when the action is executed
 			// from a toolbar within the chat widget, then make sure
 			// to move focus into the input field so that the controller
@@ -480,7 +495,7 @@ export class StartVoiceChatAction extends Action2 {
 			// TODO@bpasero this will actually not work if the button
 			// is clicked from the inline editor while focus is in a
 			// chat input field in a view or picker
-			context.widget.focusInput();
+			widget.focusInput();
 		}
 
 		const controller = await VoiceChatSessionControllerFactory.create(accessor, 'focused');
